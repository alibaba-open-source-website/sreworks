<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://sreworks.opensource.alibaba.com/column</id>
    <title>SREWorks Blog</title>
    <updated>2023-05-30T05:31:40.000Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://sreworks.opensource.alibaba.com/column"/>
    <subtitle>SREWorks Blog</subtitle>
    <icon>https://sreworks.opensource.alibaba.com/img/favicon.ico</icon>
    <entry>
        <title type="html"><![CDATA[突破规模化运维瓶颈-SREWorks云原生数智运维平台揭秘]]></title>
        <id>/ufy6glg0whe99mom</id>
        <link href="https://sreworks.opensource.alibaba.com/column/ufy6glg0whe99mom"/>
        <updated>2023-05-30T05:31:40.000Z</updated>
        <summary type="html"><![CDATA[突破规模化运维瓶颈是诸多IT规模增长的企业及组织当前遇到的比较棘手的问题。面对这些问题，多数人的第一反应是上云。但是上云之后我们会发现，即使云上的架构规模增大，也依然存在同样的问题，有时候甚至更严重，因为弹性扩容的云服务器远比买一台物理机更方便，从而导致集群规模也急剧增加。那么，规模化运维为什么会遇到瓶颈？总的来说，规模化运维遇到的瓶颈可以分为三类，分别为稳定性瓶颈、成本瓶颈以及效率瓶颈。]]></summary>
        <content type="html"><![CDATA[<a name="jrNvh"></a><h1>引言</h1><p>突破规模化运维瓶颈是诸多IT规模增长的企业及组织当前遇到的比较棘手的问题。面对这些问题，多数人的第一反应是上云。但是上云之后我们会发现，即使云上的架构规模增大，也依然存在同样的问题，有时候甚至更严重，因为弹性扩容的云服务器远比买一台物理机更方便，从而导致集群规模也急剧增加。<br>那么，规模化运维为什么会遇到瓶颈？<br>总的来说，规模化运维遇到的瓶颈可以分为三类，分别为稳定性瓶颈、成本瓶颈以及效率瓶颈。</p><p><img loading="lazy" src="/assets/images/1685424701800-68ef5d6b-1b69-4e95-829d-3d2f8fe95e8c-721c634c6e937ff40999fabfcb74920b.png" width="1267" height="639" class="img_ev3q"></p><p>第一，稳定性瓶颈，这往往是我们最关注的点。对稳定性影响最大的因素是变更，由变更导致的故障占据70%-80%。因此，我们一般会通过严管变更来减少故障时间，进而提升系统的稳定性。<br>这会导致出现一种微妙的平衡：如果限制变更的次数，则我们会选择将多个变更集中在一次变更里进行，而这会增加回滚的难度，从而导致单次的故障时间变长；而如果不限制变更次数来约束每个变更必须能够回滚，则我们可能会将一个变更分拆为多个变更，虽然出了问题可以立即回滚，影响小，但由于变更总量较大，最终系统的可用性会陷入瓶颈，无法提升。<br>除此之外，在大规模集群中，在成千上万的机器里总会出现一些性能存在问题的机器，可能是硬件问题，可能是内核问题，也可能无法明确问题。而这些机器使得整个系统在某些性能或功能上表现出不明原因的不稳定，如果无法在第一时间抓住它，则会持续产生影响。<br>以物理机为例，物理机的硬件日化故障率约0.03%，而在所有硬件故障中，有1%属于比疑难杂症，无法明确。如果机器保有量为1万台，则平均每月会碰到一例非典型的疑难杂症，影响业务。由此可见，在规模化的效应下，原本罕见的问题会变得常见。<br><strong>第一、成本瓶颈：</strong>在过去的一段时间里，这类瓶颈可能不太被重视，但是在降本增效的今天，这些问题变得尤为突出。<br>热点机器是在分布式系统中常出现的问题，明明有大量可用资源，而流量却都打到一台机器上，导致整个集群性能低。而热点机器的成因非常复杂，可能是架构问题，可能是业务问题，也有可能是底层软件、硬件的问题。<br><strong>第二、成本瓶颈：</strong>另一方面包括从预算到执行的精细化管理。如果是物理机，则需要考虑采购周期；如果是云服务，则需要考虑区分包年、包月、按次计费等计价模型，还需考虑不同区域费用单价的差异。如果无法很好地对上述问题进行管理，则会导致弹性弹得越猛，成本越高。<br>资源使用的削峰填谷是成本方面需要解决的更高难度的问题。在空间维度上，可以用算法来计算如何减少跨地域依赖，从而节省成本；在时间维度上，可以通过白天运行应用服务，晚上运行离线计算来最大限度利用机器资源。<br><strong>第三、效率瓶颈：</strong>该类问题往往发生在人机交互之中。<br>在全自动化的流程中，为了业务需要可能会配置特例化的人工干预节点，导致后续人工干预越来越频繁。那么，如何在业务定制和自动化的标准中保持中立、保持平衡？<br>一个管理平台往往有非常多的功能和配置，配置是直接暴露YAML或JSON，还是提供可视化的人机交互，也是很大问题。如果提供很多可视化交互，可能会带来较高的开发成本；但如果直接暴露YAML，手工改动的话格式又非常容易出错。<br>另外，某些小问题原本很好排查，但在大规模集群中可能需要串联上下游许多机器才能发现，导致排查小问题的时间开销也变得越来越大。<br>那么，如何解决上述瓶颈中涉及的问题？</p><p><img loading="lazy" src="/assets/images/1685424702219-8dc5e172-65c9-44cd-ac8b-a0d54be5383a-c17b3030d852afce33d1077b2b3c2490.png" width="1268" height="650" class="img_ev3q"></p><p>经过大量实践，我们总结出了一套规模化运维的流水线。流水线里包含6大环节，分别是交付、监测、管理、控制、运营、服务。<br>有了全链路图之后，我们可以按图索骥进行查漏补缺。对于已经拥有的能力，可以演进增强；对于尚未拥有的能力，可以用成熟的开源方案进行补位。</p><p><img loading="lazy" src="/assets/images/1685424702557-5897ae2a-7953-4833-83f9-ba9c8e65e72b-e2d470d9aed5faf5188a80fa84d79a1e.png" width="1268" height="705" class="img_ev3q"></p><p>上图展示了业界常见的开源方案对于上述6大环节中能力的支撑。</p><ul><li>Prometheus：能够进行时序数据的存储、监控和告警，能够满足规模化运维的指标监控需求，但是只针对“监测”技能点。</li><li>Grafana：能够接入各种数据源，进行图表、仪表盘的可视化展示。虽然无法与专业的BI工具抗衡，但是应对规模化运维的管理和运营已经绰绰有余。</li><li>Ansible：基于SSH的配置管理工具，在物理机时代特别适用。但是在云原生时代，配置和部署都已转移到K8S上，因此已经不太使用。</li><li>Docker：以一己之力开启了容器的技术革命，真正意义上实现了构建一次、随处运行。基于Docker可以完成小规模的交付管理和控制，但尚且无法应对大规模。</li><li>Elasticsearch：作为分布式的搜索和分析存储引擎，通过query，它能够提供各种数据来满足运营和服务的需求，其生态制完善，用户接入以及使用体验非常好。</li><li>Kubernetes：云原生领域的既定标准，被广泛用于解决大规模云计算环境中的管理问题，可以基于K8S完成所需要的任何事情。</li></ul><p><img loading="lazy" src="/assets/images/1685424702863-ca5bc3de-5851-42e4-ad3e-f9f3a259f322-aaa88eddbb23144a996f820332f3dd1d.png" width="1268" height="658" class="img_ev3q"><br>飞天5K项目是中国计云计算领域里程碑式的项目，我们团队承担了其中的运维工作。超大规模集群的运维保障工程使我们沉淀了一个运维平台，在内部被称为ABM（Apsara Big Data Manager），飞天大数据运维平台。</p><a name="U2pEH"></a><h1>云原生时代的架构变革</h1><p>云原生为什么能够带来巨大的变革？我们从没有被注意过的角度来聊一聊云原生时代的变革。</p><p><img loading="lazy" src="/assets/images/1685424703235-57621ea6-be9d-4aaa-8593-2f028a3d1fa6-231d9cf06c385bd843fd84050846dbd8.png" width="1616" height="910" class="img_ev3q"><br>1830年，英国铁路上出现了箱式运煤的容器。受限于火车车厢数量，集装箱对于铁路货而言提升非常有限。但集装箱到了海运的货船上立马出现了质的飞跃，世界上第一艘集装箱船装了200个集装箱，相比较同货运量的船，卸货时间从7天压缩至15小时。<br>这让我们感受到了标准化的威力，它没有让船开得更快、变得更大，但却彻彻底底地改变了全球贸易的形态，不同国家的消费者和买家被紧紧地连接在一起。而如果没有集装箱，这一切都不会发生。<br>从某种意义上来说，全球物流改变的关键点不是船只的大小，不是飞机的时速，也不是铁路的里程数，而是集装箱。<br>而Docker的出现也像集装箱一样，为软件的开发以及部署带来了标准化。<br>在Docker出现之前，研发和运维都面临着诸多挑战，我们常常为环境差异引起的部署问题焦头烂额。Docker出现之后，几乎是一锤定音，大家结束了争吵，不约而同地选择了这个方案。<br>在对容器进行标准化之后，业界又对容器的部署方案有了各自的想法。Docker推出了swarm，谷歌开源了K8S，最终K8S的Pod方案脱颖而出，既解决了隔离的问题，又满足了共享的需要。<br>云原生上标准化的容器以及运行时被统一之后，会发生什么？没有人知道，但我们也许会见证历史。</p><p><img loading="lazy" src="/assets/images/1685424703723-6e3cad17-3836-4463-afa4-1d07f37ed18d-a0a869c3d52be8e0b93eb0f77046e5c4.png" width="1268" height="724" class="img_ev3q"></p><p>Kubernetes如何改变运维体系？<br>在K8S之前，运维的主要工作是在每台机器上部署agent，然后将其中的信息采集上来，汇总到中心，同时中心也能下发指令给agent做很多工作。更新迭代的原因可能是agent不够稳定、不够强大，也可能是server不够强大。<br>但是K8S出现之后，它强大的api server能力顿时使所有server相形见绌。只需掌握一到两个接口的用法，便可以推算出几乎所有的接口，非常强大且非常优雅。<br>另外一端，在基础设施之上，在kubernetes上暴露了CRI（运行时）、CSI（存储）和CNI（网络）三种接口，满足了容器的所有部署需求。<br>该设计牢牢地将基础设施和应用负载区分开来。关注基础设施，则关注node往下部分；关注应用，则关注Pod向上部分。应用层的部署以及维护的逻辑到Pod即结束，基础设施的维护只在node之下，原则上不会与任何Pod有关，而且Pod无状态，如果node要重启，Pod会飘到其他node上。<br>基础设施是不可变的，如果在设计时将基础设施信息掺杂到应用中，则会为后续带来极大的不便。基础设施不变，但应用要变，此时往往需要订正数据。因此，我们会思考，有什么办法能将应用和基础设施区分开。<br>K8S很好地实现了这一点。很多运维工具或平台并非无法实现此能力，而是在功能复杂之后，由于一开始设计不够完善导致有些定位会变形，最终导致很多基础设施层的信息和应用层的信息被揉到一块。<br>而在SREWorks数智运维平台中，我们严格遵循“区分不变的基础设施和灵活的无状态部署应用”原则。</p><a name="IR8tM"></a><h1>规模化运维工程实践</h1><p><img loading="lazy" src="/assets/images/1685424704128-0b67edfb-cdac-450f-8d63-afb371b25343-cc5e3e1bac745cf16bbff9f46d12839c.png" width="1268" height="686" class="img_ev3q"></p><p>Too Big to Fail（大而不能倒）是我们时常面临的架构困境。IT设施愈发庞大之后，会出现各种流程和接口，为了收敛问题以及提升效率，通常会将它们收敛到统一的平台，平台的功能增多之后，重要的功能会被独立为几个子平台来承载。<br>而不同的平台会由于各种原因衍生出不同的研发流程，有些底层模块在停止迭代一段时间之后，已经无法运行构建和发布流程，从而导致我们不得不维护某些特别慢且低效的模块，有些无法修复的bug只能通过不断在外围加辅助逻辑的方式解决。这种情况类似于经济学领域的Too Big to Fail：具有关键地位的大公司破产会影响到整个社会，于是要不断将人民的血汗钱投入进去，以维持这些公司的运作。<br>很多平台都会陷入困境，即便投入很多精力在维护，稳定性和可靠性依然很差。此时可能有人会选择重构，但是如果没有优秀的顶层设计，过了几年之后平台依然会陷入类似的困境。<br>我们可以将目光转到移动互联网领域，看看它从功能到平台演进历程。</p><p><img loading="lazy" src="/assets/images/1685424704554-33842269-949e-4838-8d6e-bffb2d57a159-76b8e5243cbbdaec341555fc385ef481.png" width="1267" height="631" class="img_ev3q"><br>众所周知，iPhone的推出引领了移动互联网的革命。原本在诺基亚手机中的功能块都演进成了应用，用户可以根据自己的需求在appstore中下载和安装应用，这种应用模式极大满足了用户各方面的需求。久而久之，某些应用也变得特别庞大，功能众多，变得像一个平台，包含了各种功能，比如微信、支付宝。<br>于是，在这些应用中演化出了应用生态。这些不同于手机应用的应用，可以称为小程序（微信小程序或支付宝小程序）。优秀的平台会有应用生态来支撑其功能，里面的应用亦是如此，像一层又一层的应用套娃。<br>回到架构之上，理想的平台架构应该是怎么样的？<br><img loading="lazy" src="/assets/images/1685424704956-455b6bc3-ed0a-48dd-be27-72e384dc07e4-8427e0e00f9dc6501c1f3fa56ed8c0d7.png" width="1268" height="660" class="img_ev3q"></p><p>如果将应用作为功能载体，平台负责应用管理，则可以较好地管理这些功能。对于复杂或重要的功能，引入平台化的应用管理可以继续深入展开。但是做一个应用平台需要考虑很多方面的因素。<br>它需要有标准的应用模型，用户能在改应用模型之下开发出各种应用，满足业务需求。应用需要有一套健全的开发部署体系，实现快速迭代、快速交付。同时，应用开始运营后需要有监控，有运维来保障稳定性。针对这些经验的结论，我们给出了标准的应用模型，一套包含6大环节交付、监测、管理、控制、运营服务的工程实践，使得我们可以工程化地实现规模化运营。</p><p><img loading="lazy" src="/assets/images/1685424705395-28be9908-e12f-4468-a46a-7df616f0df98-c3ed819f99cd82996b6094214bd13a27.png" width="1269" height="680" class="img_ev3q"></p><p>云原生下的应用模型Open Application Model是由阿里云和微软共同推出的开放的应用模型，旨在为云原生应用提供开放的标准，解决应用开发和部署的挑战。<br>OAM的核心概念包括应用application、组件component以及运维特征traits，其主要特征包括：</p><ul><li>应用为先：应用的交付与部署都为自包含，其中各类操作行为都应该作为应用定义的一部分，这些内容与实际的基础设施无关。</li><li>清晰和可扩展性：定义一套开放标准，可以模块化整个应用交付流程，根据个人需要将这些模块自由组装，满足业务需求。</li><li>云服务供应商无关：自定义的开放标准应该是一套更高级别的抽象，可以跨本地集群、跨云服务供应商，不会被锁定到任何厂商的底座。</li></ul><p>OAM通过一系列的概念定义，完成了对应用的抽象，实现了角色职责分离，将应用交付与底座解耦，开发无需关心底座实现的细节，只需关心自己的应用模型。同时，应用运维再也无需担心应用内部与底座相关的各种问题，只需提供应有的component和traits，应用即可运行。</p><p><img loading="lazy" src="/assets/images/1685424705811-e107957c-0e16-4c3e-92a8-bd77ea9c77b9-3cb0d21c081126e489dfc6504b0a1d90.png" width="1268" height="699" class="img_ev3q"></p><p>基于应用引擎，可以按照application和component的模式逐层垒起应用积木。<br>我们先在应用引擎之上实现了运维应用管理swadmin，其中含有一套前端的低代码引擎，能快速开发后端接口，编排前端页面，快速落地整个运维应用。运维应用便可在应用市场里上线各种功能，争奇斗艳。<br>大数据应用管理的运维应用来自于阿里内部，用以支持阿里内部的大数据产品需求，实现阿里云上所有大数据产品的交付、售卖以及管控能力，它也是基于AppManager和OAM实现的应用工厂。<br>另一运维应用——企业应用管理，已经被放在开源的SREWorks之中，作为通用的应用管理，用于支撑开源场景的通用应用需求。很多公司已经基于企业应用管理开发出自己的业务应用，同时在此之上定制了很多自己需要的运维能力。</p><p><img loading="lazy" src="/assets/images/1685424706243-6769052e-27b2-4192-9b88-c545bd71ec9a-fdeddbe51e66be40192a60750dabcb6d.png" width="1182" height="678" class="img_ev3q"></p><p>上图为SREworks运维桌面，桌面上按照交付、监测、管理、控制、运营、服务6大场景分别内置了很多应用。<br>下文为运维应用开发演示。</p><p><img loading="lazy" src="/assets/images/1685424706739-aadbef11-8a9c-4b5e-b69e-f983f14b5a86-0acc6c8fea1736f790eb8ce2598df7d2.png" width="706" height="652" class="img_ev3q"></p><p>首先，创建运维应用。</p><p><img loading="lazy" src="/assets/images/1685424707009-a463f40e-5408-4c40-950d-6a3deeddf0c3-fc787fc24897e9e732665b16dd5bb53c.png" width="1170" height="622" class="img_ev3q"></p><p>对运维应用开启前端。</p><p><img loading="lazy" src="/assets/images/1685424707324-4a47329f-f90a-44e1-884b-bcee5c271707-57d2da09af9155ffc9f1d7fad4eb2c80.png" width="1166" height="678" class="img_ev3q"></p><p>在布局中选择放入一个表格。</p><p><img loading="lazy" src="/assets/images/1685424707748-e4413b1a-1218-4152-aaa4-f823cb26a610-ee2ed25540a66c7cd4f55429c71e5b81.png" width="1172" height="622" class="img_ev3q"></p><p>放入一个面积图。</p><p><img loading="lazy" src="/assets/images/1685424708283-6db4c64c-c9d9-4579-877d-38274722bda7-8ceaf4ed8108add0bcee01fbed7a013c.png" width="1178" height="666" class="img_ev3q"></p><p>后端新增微服务，即可将后端的接口直接打包为Docker镜像。</p><p><img loading="lazy" src="/assets/images/1685424708753-0d275e20-35e0-4db0-94af-1f6fb5aae944-3c510cd99ce9156375b826779c69a844.png" width="1176" height="656" class="img_ev3q"></p><p>点击一键构建，前端应用会开始被进行打包。</p><p><img loading="lazy" src="/assets/images/1685424709100-86572b1d-c819-49ce-8576-107ea423d756-ad0672d17b3351e99418edf8d3c6cf74.png" width="1176" height="592" class="img_ev3q"></p><p>可以看到几个模块，前端被打包好之后，即可将其上架到市场。</p><p><img loading="lazy" src="/assets/images/1685424709519-7642cd9b-42d2-4257-967b-27a6a94866e1-408702760b34d9a1be6121bf0f917bcc.png" width="1192" height="660" class="img_ev3q"></p><p>针对该应用进行一次部署。</p><p><img loading="lazy" src="/assets/images/1685424710052-c9d6ae27-f347-4519-a3aa-3cf81c0ac964-23edd1c966b9c415c621e8c919102e5d.png" width="1176" height="514" class="img_ev3q"></p><p>部署完成之后，即可在应用实例列表看到该应用，点击可以查看应用界面。</p><p><img loading="lazy" src="/assets/images/1685424710503-86465d2b-35ce-44a8-98a5-db53a4d77bfc-3a4c059f56edd1b182dd2b7ffbe0cf06.png" width="1180" height="696" class="img_ev3q"></p><p>另外，我们对运维应用提供了导入开发的功能，可以将内置的应用导入进来做二次开发。</p><p><img loading="lazy" src="/assets/images/1685424710879-b1fe227c-e24b-4be7-b885-acc77c6a0404-36c4f420e028a0970c4cd410350cca7c.png" width="1170" height="614" class="img_ev3q"></p><p>可以直接修改应用列表里表格，定制数据源等。<br>SREWorks上所有的功能都可以基于运维应用的能力，通过功能堆叠的方式实现。</p><p><img loading="lazy" src="/assets/images/1685424711265-54f00082-eb77-4c38-8312-a2270ab6ec04-d0793601496c5e234fe3ffcb52290051.png" width="1164" height="654" class="img_ev3q"></p><p>应用管理是另一款较为特殊的应用。在应用管理中可以再开发一个企业应用。<br>应用管理中有AppManager赋能的二级应用工厂。不局限于运维应用，它可以由用户完全定制自己业务相关的应用。</p><p><img loading="lazy" src="/assets/images/1685424711636-da497727-df27-4c20-927c-b527f595eb0a-b9e754850018954bc95784105e6e97b3.png" width="1194" height="670" class="img_ev3q"></p><p>比如业务上需要开发一个商城。</p><p><img loading="lazy" src="/assets/images/1685424712044-d8feaa3b-f971-4c33-891a-15ca34ed29dc-b8c3dfef0285d11dd0237b7730a9b603.png" width="1098" height="576" class="img_ev3q"></p><p>可以添加自定义的组件，也可以添加微服务组件和helm组件等。</p><p><img loading="lazy" src="/assets/images/1685424712382-887ef6d3-e3c8-46a1-8b10-0f1330c5a13d-bf15db2d0aa2102cb21ed2216b20f366.png" width="1082" height="618" class="img_ev3q"></p><p>观测定义模块可以让用户定义业务应用如何进行指标的观察，观察完指标之后可以定义应用的风险、告警、异常、故障等，并进行构建。后续流程和使用与运维应用非常相似，得益于应用工厂的方式，用户可以更快速地构建自己的各种业务应用。当前，阿里内部也采用该种方式服务大数据的产品构建。</p><p><img loading="lazy" src="/assets/images/1685424712713-1765ef60-ecfe-4681-927f-f68ccd64898d-79478bec8ce37a550e2d9eb31c66a410.png" width="1956" height="934" class="img_ev3q"></p><p>插件中的组件可扩展，当前只有helm和microservice两种组件，可以根据业务需要开发自己的工作负载以及运维特征。</p><a name="R2VVl"></a><h1>AI+大数据的数智运维实践</h1><p><img loading="lazy" src="/assets/images/1685424713169-2c07da21-351b-4e4f-acc5-cd1a80481a4f-7195cfc91edea590778e86bb0be6305c.png" width="1267" height="662" class="img_ev3q"></p><p>AIOps是人工智能在运维领域的常见运作框架。其主要流程如下：<br>首先，观测（Observe）时序数据和文本数据流，然后用算法对其做分析和洞察，发现其中的问题。其次，参与（Engage），将上一步发现的问题以及结果共享给团队中的成员，共同对结果进行讨论、分析以及优化，将人工干预的结果进一步反馈，喂给算法。最后，通过一步步打磨，将原先由人类完成的事情全部赋能于机器，从而实现全自动的运维，比如自动弹性扩缩容、故障自愈等。</p><p><img loading="lazy" src="/assets/images/1685424713695-ae8f4877-fe82-46b3-a5c6-bcb0df596814-d7bd1bd0ccea4c5f6a68729777c6974a.png" width="1267" height="699" class="img_ev3q"></p><p>AIOps具体落地的应对策略在于内核、场景和需求。<br>我们抽象了交、监、管、控、营、服6大场景，基于数据化和智能化的内核向外扩散落地四大需求——质量（稳定性）、成本、安全、效率。<br>数智内核实现了四大需求，为什么还需要六大场景？<br>这是为了解决大工程下的功能复用问题，如果没有以上场景做收敛，很多功能会发散。比如异常检测可能会由于业务的细微差异，出现多个工程实现。<br>足够的通用和抽象，也是落地工程中的重要考量原则，在同一个场景下，会尽量使用同一套方案实现。<br>观测通常可以分为两类，一类是以metric为代表的时序数据，另一类是以日志为代表的文本数据。</p><p><img loading="lazy" src="/assets/images/1685424714183-5167fd64-939f-4828-be55-7d3e9aadbee9-84dadca6c97d2a6de96b668ca19f951f.png" width="1267" height="710" class="img_ev3q"></p><p>Metric的异常检测——无阈值监控，指让机器自己发现指标中的不正常数值，并且进行报警。它与人为设置的阈值不一样，异常检测讲究的是无阈值监控，在大规模集群的指标监测中常常能够发挥较大作用。<br>异常指标的检测一般包括均值的变化、方差的变化、尖峰探测、断崖式的跌落和趋势预测，基本涵盖了人类认知中判断异常的方法。<br>在大规模使用异常检测时，建议可以先对顶层的运营指标进行异常检测，这类指标通常会配有运营报表，可视化程度高，针对异常点的排查也非常方便。即使没有检测出异常，对于出错的容忍度也较高。运营指标接入异常检测之后，可以逐步向底层渗透，替换生产环境的固定阈值报警。<br>异常检测能力已经在SREWorks中开源。</p><p><img loading="lazy" src="/assets/images/1685424714632-c0ecbd1b-c785-4607-a823-f89c290722d4-bae6783780fa2490bb188e05a7d95c93.png" width="1268" height="652" class="img_ev3q"></p><p>日志聚类——面向日志的异常告警也即将开源。<br>在日志数据中，我们常常关注的焦点是日志中的报错堆栈，久而久之，经验丰富的运维同学可能会直接写脚本监控日志报错堆栈里的关键字。但这种监控方案存在问题，软件版本更新可能会导致报错堆栈变化，关键字随即不管用，因此需要调整脚本。<br>而日志聚类是一劳永逸的办法，报错堆栈在算法眼里都属于文本模式，日志数据进来之后，可以用日志聚类将这些报错堆栈聚成若干个文本模式，从而使一份文本数据变为指标数据，只需要关注某些文本模式计数值的突增，即可感知到异常。<br>文本数值配合异常检测，即可实现AIOps完整的一条龙服务，涵盖了日志的聚类分析、模式计数、异常检测以及报警。<br>当前开源版本的日志聚类基于Flink ML构建，我们会将这份构建代码合并到近期即将发布的V1.5源码上。</p><p><img loading="lazy" src="/assets/images/1685424715173-3389b89e-72e8-4698-98d8-7032bf1ee26c-86847f62a89e47407dd4a6dd1c177388.png" width="1268" height="706" class="img_ev3q"></p><p>上图为数智运维的分层图，经过IaaS、PaaS、SaaS三层的分层之后，面向交、监、管、控、营、服六大场景，内部的数据运维平台衍生出了非常多功能来满足业务的需要。不少基于SREWorks做能力构筑的公司也在逐渐点亮图中的各个功能点。<br>数智运维体系无法一蹴而就，我们无法通过简单地点击鼠标，就得到数智运维的整个体系。我们希望SREWorks提供给用户一个用户工厂、大量工程实践的样例以及丰富的数智运维经验。希望用户在使用SREWorks之后，能够基于这些工程实践和应用工厂构筑出满足自己业务需求的数智运维体系。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SREWorks数智运维平台开源一周年 | 回顾与展望]]></title>
        <id>/qffxuwnxm5ybs2pm</id>
        <link href="https://sreworks.opensource.alibaba.com/column/qffxuwnxm5ybs2pm"/>
        <updated>2023-05-30T05:29:02.000Z</updated>
        <summary type="html"><![CDATA[2022年3月SREWorks项目正式开源，到目前为止已经整整一周年了。自开源以来，我们始终立足云原生运维场景，秉承“数据化、智能化”的运维思想，采用“小步快跑”的快速迭代方式，使得整个SREWorks项目也取得了长足的进步。于此同时，得益于社区用户、企业伙伴的积极参与和贡献，也为SREWorks项目的发展注入了新的活力。下面我们来回顾一下SREWorks的开源故事并展望其未来的发展。]]></summary>
        <content type="html"><![CDATA[<p>2022年3月SREWorks项目正式开源，到目前为止已经整整一周年了。自开源以来，我们始终立足云原生运维场景，秉承“数据化、智能化”的运维思想，采用“小步快跑”的快速迭代方式，使得整个SREWorks项目也取得了长足的进步。于此同时，得益于社区用户、企业伙伴的积极参与和贡献，也为SREWorks项目的发展注入了新的活力。下面我们来回顾一下SREWorks的开源故事并展望其未来的发展。</p><a name="uu8yR"></a><h1>开源故事</h1><p>相信大家或多或少听说过飞天的5K项目，这是中国云计算领域的一个里程碑式的项目，我们团队承担了其中的运维工作。超大规模集群的运维保障任务，让我们意识到：如果没有系统性的运维工程，即便我们再殚精竭虑，集群稳定性也是会是一件靠天吃饭的事情。于是我们逐步将大量的运维实践进行工程化落地，使之成为了一个可靠的运维平台，在内部我们称之其为ABM：Apsara Bigdata Manager -- 飞天大数据运维平台。<br>有了ABM之后，我们常常会对外分享平台化的运维工程实践，也收到了较好的同行反馈。本着 "Talk is cheap. Show me the code." 的想法，我们进一步探索如何将这些平台工程实践代码进行开源，帮助更多从业者提升运维效能。<br>随着云原生以及Kubernetes集群的大量推广，我们发现这些大规模的工程实践，同样适用于k8s集群。于是，我们对ABM进行了分层改造，升级为应用引擎 + 运维平台的模式。抽取其核心引擎部分为AppManager，使用OAM作为应用模型，其原理及实现可以参考如下文章：<br><a href="https://mp.weixin.qq.com/s/zCKS-Lkv-EVTCFPfhmGqDg" target="_blank" rel="noopener noreferrer">QCon演讲实录（上）：多云环境下应用管理与交付实践</a> <a href="https://mp.weixin.qq.com/s/VA6n3EbRMyL199Qj6cQE5g" target="_blank" rel="noopener noreferrer">QCon演讲实录（下）：多云管理关键能力实现与解析-AppManager</a><br>同时，我们将运维平台ABM移植到k8s集群下，并进行了优化裁剪，这个过程有点像从Mac OS X中裁剪iOS--我们将这个裁剪出来平台命名为SREWorks。有了SREWorks之后，我们的各种对外经验分享对于同行来说不再处于隔靴搔痒的状态，我们有方案有实践有代码可落地。</p><a name="rhz7J"></a><h1>开源历程</h1><p>在这一年时间里，SREWorks进行了几次重要的版本发布：</p><table><thead><tr><th>日期</th><th>版本</th><th>说明</th></tr></thead><tbody><tr><td>2022/3/22</td><td>v1.0</td><td>工程代码首次公开推送</td></tr><tr><td>2022/5/9</td><td>v1.1</td><td>组件插拔场景化部署能力 <a href="https://mp.weixin.qq.com/s/_kqItPbivVmIrOVXvEaVlg" target="_blank" rel="noopener noreferrer">SREWorks v1.1 版本发布 <!-- -->|<!-- --> 组件插拔场景化部署能力</a></td></tr><tr><td>2022/6/21</td><td>v1.2</td><td>公共应用市场上线，数据平台能力增强 <a href="https://mp.weixin.qq.com/s/9zEzKs-NpRciPA2cZzduyA" target="_blank" rel="noopener noreferrer">SREWorks v1.2 版本发布 <!-- -->|<!-- --> 新增运维市场能力</a></td></tr><tr><td>2022/11/16</td><td>v1.3</td><td>应用插件机制上线 <a href="https://mp.weixin.qq.com/s/9Em8xMxuuPHcC7mBtvTEhQ" target="_blank" rel="noopener noreferrer">SREWorks v1.3 版本发布 <!-- -->|<!-- --> 插件机制发布</a></td></tr><tr><td>2023/1/6</td><td>v1.4</td><td>纯内网离线安装方案支持，底座支持热升级 <a href="https://mp.weixin.qq.com/s/dd75QNDspOIyx9wOSNoK_A" target="_blank" rel="noopener noreferrer">SREWorks v1.4 版本发布 <!-- -->|<!-- --> 离线安装|前端重构</a></td></tr></tbody></table><p>承蒙广大开发者和用户的支持与认可，SREWorks在2022年底被InfoQ评为开发者最喜爱的十大开源项目。<br><img loading="lazy" alt="image.png" src="/assets/images/1685424555596-a124ddd3-e6b6-4489-abaa-249587252283-9c64d8fa63b07da236705ee900c3c8f1.png" width="957" height="835" class="img_ev3q"></p><a name="ZxaeH"></a><h1>开源意义</h1><p>在这开源的一年里，在与外部的讨论沟通上，我们常常会不可避免的碰到这么一个问题：为什么国内开源项目做成功的这么少？我们可以从开源项目使用者的角度，来思考这个问题：一个开源项目应该更像个工程还是更像个工具？似乎优秀的开源项目通常两者兼有之：<strong>方便快捷的工具帮助开发者快速解决问题，吸引他们快速入坑；工程的深度吸引业界高手持续往里填坑。</strong>反之，缺乏工程深度项目能帮助用户解决短平快的问题，但无法持续发展，而缺乏快捷工具的工程如无源之水无本之木，还未积累足够的用户基数用户案例就枯竭了。<br>再往深分析一层，为什么国内开源项目常常会陷入上段提到这些困境？因为开源项目的推广并不像朋友圈的点赞，认同这个项目的人，会将这个项目实际用起来，继而接纳开源项目作者在项目中所传达的思想及方法。所以开源项目必须要有其独创性，才能服众，否则使用者就会产生一种“好像我也行”的冲动另起炉灶。这就像老生常谈的那句话“一流企业做标准、二流企业做品牌、三流企业做产品”，一个优秀的开源项目常常引导了这个领域的一些标准的落地。<br>我们希望通过SREWorks数智运维平台，让更多从业者利用“大数据和人工智能”的能力做好运维，进入到“数据化、智能化”时代。从代码到线上业务服务的全流程，我们划分了“交付、监测、管理、控制、运营、服务”六大场景，每个场景中都其有代表性的核心功能。<br><img loading="lazy" alt="image.png" src="/assets/images/1685424555141-02829229-516e-49e2-b10a-1c7c457486d9-ad2aadba563a983f0ec41cd29a147f22.png" width="1500" height="614" class="img_ev3q"></p><a name="uiZyU"></a><h1>开源生态</h1><p>围绕着SREWorks数智运维平台，我们秉承开放协作共享的理念，致力于构建一个人人可参与的生态圈。</p><a name="JbziO"></a><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="前端可视化生态">前端可视化生态<a class="hash-link" href="#前端可视化生态" title="标题的直接链接">​</a></h2><p>前端可视化常常成为一个产品功能快速迭代的瓶颈，SREWorks中提供了自由的前端低代码组件布局方案，无需前端开发同学配合，只需要轻松地拖拉拽一把，就可以快速将几个前端页面落地。<strong>大家在SREWorks中看到的所有功能页面，均是通过这种可视化布局产生的</strong>，我们的前端研发提供了丰富的前端组件库供布局使用，具体对此感兴趣的同学可以参考下面两篇文章或直接上手体验一把：<br><a href="https://mp.weixin.qq.com/s/0PMoNr1wtCpEpF3aJoexOA" target="_blank" rel="noopener noreferrer">SREWorks前端低代码工程设计概览</a><br><a href="https://mp.weixin.qq.com/s/dj7S2HIq_orVSAwyFXrOgw" target="_blank" rel="noopener noreferrer">SREWorks低代码组件生态演进:monorepo架构和远程组件加载实践</a><br><img loading="lazy" alt="image.png" src="/assets/images/1685424556789-cce325ca-7984-4b0b-8679-db749ba02157-6b56d5b5664855789b883dda4f063d8f.png" width="2040" height="1916" class="img_ev3q"><br>我们的前端研发同学生怕各种组件无法完全满足业务需求，想方设法提供了各类组件扩展及能力增强方案：</p><ul><li><strong>组件不够多？</strong>我们利用monorepo架构将组件部分变成一个独立的npm工程，方便开发者二次开发以及往里新增组件。</li><li><strong>接口数据格式无法完全匹配组件？</strong>我们在组件中提供各种数据处理插槽，允许用户直接写js函数来处理数据。</li><li><strong>组件的文字格式上希望做一些调整？</strong>各种展示文本均支持使用React JSX进行格式渲染增强。</li><li><strong>想嵌入一些自己开发的组件？也不是基于React开发的？</strong>没关系，远程组件加载满足你，Vue组件轻松加载。</li><li><strong>不想在本地开发代码，但想快速把几个页面元素合成一个新组件？</strong>我们支持使用React JSX在前端直接编写新组件。<a name="mcr59"></a></li></ul><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="应用及插件生态">应用及插件生态<a class="hash-link" href="#应用及插件生态" title="标题的直接链接">​</a></h2><p>在应用开发中，构建环节是至关重要的。有时候线上环境看起来十分井井有条，但是构建环境却会为了快速出包，暗藏各种脚本或有状态的小魔法。时间一长，这条清澈的小溪就会布满各种岩石、急流、暗礁，大多数情况能有惊无险地通过，但总会有那么几次问题的排查让人刻骨铭心。SREWorks基于k8s提供完整的云原生研发及构建方案，没有有状态的构建机，每次构建都是一个独立Pod，用完即毁，保持良好的弹性伸缩能力。具体技术细节可以参考 <a href="https://mp.weixin.qq.com/s/24v8J1JYgYMl4Eoakrb5dA" target="_blank" rel="noopener noreferrer">SREWorks持续交付云原生化: 镜像构建</a><br><strong>SREWorks中所有功能都是由标准的OAM应用构成的，应用就是组成平台的最小原子。</strong>同时，我们将SREWorks中的应用划分成两个大类：运维应用和企业应用：在运维应用中，我们如上文提到的“交付、监测、管理、控制、运营、服务”六大场景，内置了丰富的运维应用；在企业应用中，研发同学可以借助SREWorks的云原生研发流程快速落地功能。<br><img loading="lazy" alt="image.png" src="/assets/images/1685424558347-11b95edf-019c-41b4-a319-e466c3c0c7e8-f488ff6608b0d19a09655a6036da2d38.png" width="3458" height="1940" class="img_ev3q"><br>在v1.2版本之后，所有的SREWorks平台实例中都上线了公共应用市场，也就意味着已经部署SREWorks的用户可以通过这个公共应用市场，来持续安装以及升级应用、增强能力。我们鼓励SRE同学将各种经验沉淀成一个应用，进而设计成一个完整的应用产品，上架到市场供更多的同行使用。<br>另外一方面，为了能够满足更丰富的应用形态需求，我们在v1.3版本上线了插件机制，提供了工作负载等插槽允许用户通过插件进行扩展。当前工作负载中已有插件是微服务和Helm，后续会上架更多的插件，也欢迎有需求的公司进行插件共建。</p><a name="X0nYR"></a><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="数智运维生态">数智运维生态<a class="hash-link" href="#数智运维生态" title="标题的直接链接">​</a></h2><p>在SREWorks中我们提供了基于ElasticSearch的完整的数据运维平台以及智能运维平台，但说实话，数据化和智能化这块能力让公司来一键接入还是有难度的，于是我们基于SLS(阿里云日志服务)的SREWorks微应用，无需部署SREWorks，帮助部分用户一键体验轻量级SREWorks的数智服务，需要深入了解的同学可移步这篇文章 <a href="https://mp.weixin.qq.com/s/XAb6u5U1fU38-tkYr92VdQ" target="_blank" rel="noopener noreferrer">SREWorks 数智服务尝鲜，你的数据准备好了吗？</a><br>在智能运维算法这块，对外我们不断规划更多的算法开源，对内我们不断夯实算法理论基础：</p><ul><li>在2021年，我们与阿里云达摩院合作的时序多周期检测相关论文《RobustPeriod: Robust Time-Frequency Mining for Multiple Periodicity Detection》被SIGMOD 2021接收，这也是阿里首次以第一单位在 SIGMOD 的Research Track发表的论文。</li><li>在2021年，我们与达摩院决策智能团队合作撰写的论文《CloudRCA：面向云计算平台的通用根因分析框架》，国际顶会CIKM2021的Applied Research Track录取。</li><li>在2022年，我们与达摩院时序智能团队合作的《NetRCA: An Effective Network Fault Cause Localization Algorithm》在 ICASSP‘22 AIOps Challenge通信网络智能运维大赛获得冠军。</li></ul><p>我们欢迎在数智运维领域与使用SREWorks的公司有更多的共建与合作，持续打磨工程及算法，使之产生更广泛更更普适的价值。</p><a name="RpsWh"></a><h1>后续规划</h1><p>在<strong>引擎(Appmanager)</strong>上我们会进一步完善插件机制，同时引入更多的工作负载(workload)和运维特征(trait)来实现更丰富的应用场景。在应用持续集成(CI)链路上，我们会根据已有案例持续进行打磨能力，使得应用开发及构建方案对其他公司更加适配。<br>在<strong>平台层(PaaS)</strong>上我们会进一步增强权限体系和接口服务，使得SREWorks在其他公司中嵌入集成更加简单。同时我们会将中台能力进一步抽取，使得运维应用之间通过中台能力交叉引用更加方便高效。<br>在<strong>应用层(SaaS)上</strong>我们会根据内部新上线的功能情况进行开源，可能会包含应用管理的增强以及业务流程编排相关的功能点。<br>在<strong>数智能力(DataOps&amp;AIOps)</strong>上我们在今年会开源基于Flink ML的日志聚类算法服务，更强的异常检测服务，大敬请期待。<br>在<strong>开发者生态(Developer Ecosystem)</strong>上我们今年会进一步扩充应用市场的应用，提供更多的培训课程及文档，方便更多用户，能快速基于SREWorks完成云原生的应用开发。同时今年会上线SREWorks应用测评系统，在日常组织一些比赛进行基于SREWorks的应用开发比赛。</p><a name="eejPg"></a><h1>写在最后</h1><p>开源并非一件易事，曾有人这样问我：“你们开源是怎么活下来的？” 通过内部大量的工程实践的打磨，使得我们孵化了这样的平台，磨合了这样的一种工作方式：我们希望将这其中的价值以及思考传递给更多的人，路虽远行则将至，事虽难做则必成。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SREWorks前端低代码组件生态演进：monorepo架构重构和远程组件加载实践]]></title>
        <id>/zy8oryge2wzxtzu4</id>
        <link href="https://sreworks.opensource.alibaba.com/column/zy8oryge2wzxtzu4"/>
        <updated>2023-05-30T05:22:09.000Z</updated>
        <summary type="html"><![CDATA[作者：王威（地谦）]]></summary>
        <content type="html"><![CDATA[<p>作者：王威（地谦）</p><a name="s4onN"></a><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="文章结构">文章结构<a class="hash-link" href="#文章结构" title="标题的直接链接">​</a></h2><ul><li>项目背景</li><li>演进分析</li><li>monorepo架构演进<ul><li>Webpack与Rollup</li><li>如何平滑迁移</li><li>构建优化</li></ul></li><li>组件的可扩展与可插拔</li><li>演进总结</li><li>版本动态</li></ul><a name="TgQKm"></a><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="项目背景">项目背景<a class="hash-link" href="#项目背景" title="标题的直接链接">​</a></h2><p>SREWorks是一个面向企业级复杂业务的开源云原生数智运维平台，是大数据SRE团队多年工程实践的锤炼及沉淀。前端统一托管工程（frontend）作为平台的重要一环，提供了一套serverless体验的配置化前端低代码技术方案：低代码、配置化是前端低代码方案的基础特性。<br>frontend工程采用React+antd为主的技术框架，设计了一套组件映射、编排、解析、渲染的工程体系：以antd组件为自由编辑粒度，用户在前端设计器通过可视化交互或者json编辑的方式，依据运维工作的实际使用场景，对组件进行属性配置/组件嵌套拼装；同时根据使用景目标需求对页面组件进行布局的编排、数据源的绑定以及在合适点位插入Dynamic Logic，完成页面节点的设计工作，形成节点模型nodeModel，经模板解析引擎进行解析渲染。由于之前已对架构设计做过一篇详细的介绍，在此不再赘述，详情可移步这一篇 <a href="https://mp.weixin.qq.com/s/_kqItPbivVmIrOVXvEaVlg" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/_kqItPbivVmIrOVXvEaVlg</a><br><img loading="lazy" alt="image.png" src="/assets/images/1685424147887-114df5a3-e8e2-4a5f-9ca1-0a8e92ad613c-cb91607ff364dc8a9cb81b9b815d1ab6.png" width="1694" height="1380" class="img_ev3q"></p><p>我们开源这套前端工程的愿景是：沉淀更多的使用场景，整合更多的用户需求，与社区一起共建一个丰富的前端运维组件生态。在过去的半年中，为了让前端组件生态更好地演进，frontend 针对 “<strong>可扩展、方便插拔</strong>”这两个关键点进行架构升级：</p><ol><li>架构层面进行了monorepo模式重构；</li><li>前端组件支持远程动态加载；</li></ol><p>在文本中，我们对整个迭代过程中陆陆续续碰到过一些问题，以及技术方案的选择与思考做一个阶段性的归纳和总结。</p><a name="Z4i2B"></a><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="演进分析">演进分析<a class="hash-link" href="#演进分析" title="标题的直接链接">​</a></h2><p>关注我们开源动态的同学应该知道，我们初版开源的frontend代码量近10万之多，在没有可靠详实文档的帮助之下，想要快速理清楚整套工程的设计理念，结构机理进而能参与贡献还是有一定难度的。同时工程内部细分来看，设计器，模型层，组件层各自又有相差很大的更新频率，在开发时一个小小的改动都需要整个工程进行构建。<br>另外一方面，frontend来源于公司内部工程实践的版本，两者虽然同源，但是由于公司内部和开源场景都在快速功能演进，最初设计的公共框架层和组件层共享机制已经有些举步维艰，这也为后续这次演进迭代埋下了伏笔。结合我们打造开源生态“<strong>可扩展、方便插拔</strong>”两大目标，综合来看需要解决以下问题：</p><ul><li>基座层面支持runtime远程组件的加载，解决用户的多样化的场景与诉求</li><li>结构上对大而全的工程进行细粒度拆分</li><li>提取framework框架层和widget组件层并能够单独构建</li><li>share-tools工具可共享</li><li>内部业务代码剥离</li><li>在适配内部业务运转的前提下升级各依赖版本，便于新技术引入与演进</li><li>构建工具的升级与配置调优，有效提升构建效率降低构建体积</li></ul><p>针对以上待解决的问题，对演进方案进行了技术调研，也参考和采纳了社区同学的建议，我们决定采取下面两个方案来解决上文提到的问题：</p><ol><li>架构层面，采用monorepo模式进行重构提取出framework框架层、widget组件层、shared-tools等几个子依赖包，以webpack5(主应用包)+rollup(子依赖包)作为构建工具进行过调优构建；</li><li>针对无法进入代码库的组件，提供远程组件脚手架，支持将远程组件打包umd格式并以动态script标签形式进行动态引入和移除，做到runtime加载扩展；</li></ol><p>下面我们来详细分享下这两项方案的实施：</p><a name="yq0N6"></a><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="monorepo架构演进">Monorepo架构演进<a class="hash-link" href="#monorepo架构演进" title="标题的直接链接">​</a></h2><p>Monorepo即单仓(repository)多包(package)，大型前端工程项目采用这种模式进行开发管理，能带来诸多的开发和管理便利:</p><ul><li>更加清晰的模块结构和依赖关系</li><li>更细粒度的独立构建单元便于协作开发和不同更新频率的子包单独发版</li><li>更加高效的代码复用等</li></ul><p>在v1.4版本中采用lerna + yarn workspace 的技术方案进行了Monorepo的架构实践：将原工程拆分为@sreworks/app主包应用，和@sreworks/components、@sreworks/widgets、@sreworks/framework、@sreworks/shared-utils四个npm子依赖包。目录结构变动如下图所示：<br><img loading="lazy" alt="image.png" src="/assets/images/1685424147438-acb46449-d927-46fa-bd97-db49f9f6c960-43e97093ad6fc07b144b4930349f1516.png" width="2227" height="1139" class="img_ev3q"><br>通过lerna+yarnworkspace的方案，将各子包配置进入workspace空间，workspace空间的各子依赖包的更新，会实时同步到主应用包的node_module，无需发布npm，且能选择针对特定子包单独发布npm版本或者各个包同步发布新的版本，可以更小粒度的更新主应用依赖，便捷高效。</p><a name="fdDVr"></a><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="webpack与rollup">Webpack与Rollup<a class="hash-link" href="#webpack与rollup" title="标题的直接链接">​</a></h3><p>在设计好子包的拆分之后，就开始着手进行文件结构的改造、组件引入挂载方式的变更、远程组件加载的处理优化，主题式样的迁移等等问题（由于篇幅有限，本文仅对大的通用环节进行介绍，对处理细节感兴趣或者想讨论沟通的同学可以加入文末的交流群)。<br>在处理完工程结构代码后，我们开始着手工程的构建：构建工具的选择，关于构建工具，webpack，gulp，rollup以及后来的vite，综合我们实际的情况，最后选定了Webpack和Rollup作为备选方案：Webpack和Rollup本质都是对非ES5代码的转义与打包，一个功能强大的compiler函数，通过配置入口读取目标文件，然后输出转义文件；要完成整个工程的打包，还需要babel-loader，React和Vue等loader的处理和一系列plugin的适时挂载处理才能完成对诸如图片，css文件、JSX及Vue template等类型文件的处理，及js挂载html的工作。<br>Webpack与Rollup的特点：</p><table><thead><tr><th>工具</th><th>Webpack</th><th>Rollup</th></tr></thead><tbody><tr><td>优点</td><td><br>   - 热更新方面：webpack支持HMR<br>   - tree-shaking：webpack5有更好的tree-shaking（去除未使用代码）<br>   - 分包方面：webpack支持代码切割，有利于首页体验优化<br>   - ESM打包：现在webpack5支持es6module输出<br></td><td><br>   - 更加小巧，打包生成的文件更小<br>   - 打包的产物比较干净，没有webpack那么多工具函数<br>   - 支持tree-shaking<br>   - Rollup 的插件机制设计得相对更干净简洁，配置相对简单<br>   - ESM打包：支持<br></td></tr><tr><td>缺点</td><td>配置繁琐，自身的非业务代码嵌入较多</td><td>热更新方面：原生不支持HMR；识别commonJs需要插件</td></tr></tbody></table><p>根据以上特点对比以及参考业内优秀开源项目实践，frontend选择了主包应用使用Webpack5作为构建工具，Rollup作为子包应用构建工具的方案，主包应用HMR对于日常开发而言是刚需，因此选择Webapck；对子包依赖而言，更便捷的配置和更小的输出才是更佳的选择。<br><img loading="lazy" alt="image.png" src="/assets/images/1685424146925-d3ab05e0-0c80-4ba1-a405-0043d48a437b-44dc01f4b2f61eef24953cd94d519027.png" width="1433" height="720" class="img_ev3q"><br><img loading="lazy" alt="image.png" src="/assets/images/1685424147361-2a45c17c-6ffe-416a-a1f0-b386bbfcae03-e9e8c87330c60d3b03326b9212c81a4f.png" width="1293" height="706" class="img_ev3q"><br>	</p><a name="MwXFW"></a><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="如何平滑迁移">如何平滑迁移<a class="hash-link" href="#如何平滑迁移" title="标题的直接链接">​</a></h3><p>整个这么大的工程体量，在没有完全进行代码层面准确无误的拆解并构建的情况下，是跑不起来的，一个很小的错误都会造成整个项目抛错。且二方包使用了sourcemap也是没有用的，经过了主包构建，很难排查出哪里除了问题，于是就又要推倒重来……在开始的实时过程中，耗费了很多的时间，叠加每个子包的修改排查，主应用包的构建等验证周期很长，探索性改造的难点就在于此。<br>那么能更小粒度的验证和迁移吗？远程组件的加载给了启发思路。尝试性将组件包@SREWorks/widgets打包成esm格式并在原来大而全的工程中直接修改node_modlues引入依赖包打包文件, 和相应加载机制，在能运行起来的工程上去验证各子依赖包，配合sourcemap, 问题排查瞬间提速。就这样，又依次进行@SREWorks/framework等其他包的验证，蒙眼构建排查问题得解。<br>式样问题比较头疼，在此采用的方案是通用式样在主包保留，子包由于式样重置覆盖的场景较少，采用了css-module的方式进行隔离构建。</p><a name="I6iXy"></a><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="构建优化">构建优化<a class="hash-link" href="#构建优化" title="标题的直接链接">​</a></h3><p>经过各子依赖包在原有工程上进行平滑验证，来到主应用包的构建环节，构建体积竟然达到了惊人的5.5M，还是gzip压缩后的体积：<br><img loading="lazy" alt="构建依赖可视化分析" src="/assets/images/1685424148546-e238fed6-3690-41f2-81a9-7ff196bb6279-65bbff051fc47ee528faca94f511ed5f.png" width="2830" height="1424" class="img_ev3q"><br>通过分析这张图，该版本构建存在以下问题：</p><ul><li>同名依赖多次出现，各子依赖包存在重复的依赖</li><li>部分依赖包构建体积偏大，如BizCharts</li></ul><p>针对以上存在的问题对@sreworks/app整体进行三个维度的优化处理:<br>第一，通过统一子包依赖排查合并依赖版本，优化至2.8M<br><img loading="lazy" alt="多版本依赖项逐个排查" src="/assets/images/1685424148964-a2f8f450-0ce2-4202-9af3-03ea7710380a-f8c70a99d3780b85a3a2f3a5252c1d24.png" width="1002" height="195" class="img_ev3q"></p><div class="language-js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-js codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">const</span><span class="token plain"> namespace </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token literal-property property" style="color:#36acaa">appRoot</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> path</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">resolve</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">'src'</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token literal-property property" style="color:#36acaa">appAssets</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> path</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">resolve</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">'src/assets'</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token comment" style="color:#999988;font-style:italic">// 减少子依赖包内部重复依赖</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token string-property property" style="color:#36acaa">'@ant-design'</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> path</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">resolve</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">process</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">cwd</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">'node_modules'</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">'@ant-design'</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token string-property property" style="color:#36acaa">'js-yaml'</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> path</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">resolve</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">process</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">cwd</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">'node_modules'</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">'js-yaml'</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token string-property property" style="color:#36acaa">'ace-builds'</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> path</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">resolve</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">process</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">cwd</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">'node_modules'</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">'ace-builds'</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token string-property property" style="color:#36acaa">'brace'</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> path</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">resolve</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">process</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">cwd</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">'node_modules'</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">'brace'</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token string-property property" style="color:#36acaa">'lodash'</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> path</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">resolve</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">process</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">cwd</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">'node_modules'</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">'lodash'</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token spread operator" style="color:#393A34">...</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token literal-property property" style="color:#36acaa">resolve</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token literal-property property" style="color:#36acaa">alias</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> paths</span><span class="token punctuation" style="color:#393A34">.</span><span class="token property-access">namespace</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token literal-property property" style="color:#36acaa">modules</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">[</span><span class="token string" style="color:#e3116c">'node_modules'</span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token literal-property property" style="color:#36acaa">extensions</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">[</span><span class="token string" style="color:#e3116c">'.json'</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">'.js'</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">'.jsx'</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">'.less'</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">'scss'</span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">,</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>第二，抽离部分大依赖包到cdn，如下在externals配置项进行剥离；将体积优化至1.6M。但考虑到某些专有云使用场景，无法使用外部cdn。于是采用自定义构建脚本，从node_modules中迁移目标依赖到输出文件夹并加载至html的方案，降低参与构建的大依赖包数量，同时保证专有云环境对其正常的使用。</p><div class="language-js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-js codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token literal-property property" style="color:#36acaa">externals</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token comment" style="color:#999988;font-style:italic">// 剥离部分依赖，不参与打包</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token string-property property" style="color:#36acaa">'react'</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">'React'</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token string-property property" style="color:#36acaa">'react-dom'</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">'ReactDOM'</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token string-property property" style="color:#36acaa">"antd"</span><span class="token operator" style="color:#393A34">:</span><span class="token string" style="color:#e3116c">"antd"</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token spread operator" style="color:#393A34">...</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">,</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>第三，调整关键组件路径和1.48M, 减少体积70%，构建时间由V1.3版本的74秒，优化至23秒，提升68%。<br><img loading="lazy" alt="image.png" src="/assets/images/1685424150049-2b7493fc-ee0d-4b56-8f22-7616ef2a9297-f80e6df6e2ec5bc01a3cae6b679474d0.png" width="2848" height="1434" class="img_ev3q"></p><a name="DK4E4"></a><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="组件的可扩展与可插拔">组件的可扩展与可插拔<a class="hash-link" href="#组件的可扩展与可插拔" title="标题的直接链接">​</a></h2><p>虽然frontend已内置运维场景常用的基础组件，图表组件，landing组件，布局组件等五十余个组件。根据开源之后用户的使用反馈来看，用户仍然有着定制化，可扩展的共性诉求：总的来讲大致分为两大类：</p><ol><li>前端框架也是React，有自己定制化的使用场景，内置组件不能满足当前需求，需要扩展</li><li>前端技术栈是Vue，历史组件积淀比较多，全部进行React重构成本太大</li></ol><p><strong>针对问题一</strong>，frontend本来就有提供JSXRender，支持用户以JSX进行简单的静态渲染类的组件自定义扩展，但不支持属性配置以及数据源及dynamic业务逻辑处理等高级特性。前端插件化，很容易想到npm包的引入，但是这也只能在工程代码开发的场景下才适配，要runtime使用和移除，就要另寻方案。再进一步深入追溯，前端开发从jQuery时代发展到当今的Agular，React，Vue三驾马车以及各种工程化构建工具的参与，但本质其实并没有发变化，依然是以html中以script标签挂载js代码进行渲染加载的。因此自然想到以script标签的形式加载我们的远程组件，不过这里要做到动态、批量加载、可移除，即：将远程组件打包umd格式并发布到云端，并获取相应准确路径，以动态script标签的形式引入：</p><div class="language-js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-js codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">(</span><span class="token keyword" style="color:#00009f">function</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token keyword" style="color:#00009f">let</span><span class="token plain"> script </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token dom variable" style="color:#36acaa">document</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">createElement</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">'script'</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  script</span><span class="token punctuation" style="color:#393A34">.</span><span class="token property-access">type</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token string" style="color:#e3116c">'text/javascript'</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  script</span><span class="token punctuation" style="color:#393A34">.</span><span class="token property-access">src</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> url </span><span class="token comment" style="color:#999988;font-style:italic">// 目标组件url</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token dom variable" style="color:#36acaa">document</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">getElementById</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">'targetDomId'</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">appendChild</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">script</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">script</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">addEventListener</span><span class="token punctuation" style="color:#393A34">(</span><span class="token string" style="color:#e3116c">'load'</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain">callback</span><span class="token punctuation" style="color:#393A34">,</span><span class="token boolean" style="color:#36acaa">false</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token comment" style="color:#999988;font-style:italic">// 嵌入逻辑</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>如果要批量加载多个的话，即：</p><div class="language-js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-js codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token keyword" style="color:#00009f">const</span><span class="token plain"> </span><span class="token function-variable function" style="color:#d73a49">loadRemoteComp</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">async</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token arrow operator" style="color:#393A34">=&gt;</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token keyword" style="color:#00009f">let</span><span class="token plain"> remoteCompList </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">[</span><span class="token string" style="color:#e3116c">"url_a"</span><span class="token punctuation" style="color:#393A34">,</span><span class="token string" style="color:#e3116c">"url_b"</span><span class="token punctuation" style="color:#393A34">,</span><span class="token string" style="color:#e3116c">"url_c"</span><span class="token punctuation" style="color:#393A34">,</span><span class="token spread operator" style="color:#393A34">...</span><span class="token punctuation" style="color:#393A34">]</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token keyword control-flow" style="color:#00009f">try</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    remoteComList</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">forEach</span><span class="token punctuation" style="color:#393A34">(</span><span class="token parameter">item</span><span class="token plain"> </span><span class="token arrow operator" style="color:#393A34">=&gt;</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      pros</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">push</span><span class="token punctuation" style="color:#393A34">(</span><span class="token known-class-name class-name">Promise</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">resolve</span><span class="token punctuation" style="color:#393A34">(</span><span class="token function" style="color:#d73a49">loadSingleComp</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token dom variable" style="color:#36acaa">window</span><span class="token punctuation" style="color:#393A34">[</span><span class="token string" style="color:#e3116c">'REMOTE_COMP_LIST'</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token keyword control-flow" style="color:#00009f">await</span><span class="token plain"> </span><span class="token known-class-name class-name">Promise</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">all</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">pros</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"> </span><span class="token keyword control-flow" style="color:#00009f">catch</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">error</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token console class-name">console</span><span class="token punctuation" style="color:#393A34">.</span><span class="token method function property-access" style="color:#d73a49">log</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">error</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">;</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token function" style="color:#d73a49">loadRemoteComp</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">)</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>当然这里还涉及到浏览器终端适配，容错等细节。在此frontend采用比较成熟的systemjs包进行组件的加载，对以上细节都有做妥善处理，合理借力，省时高效。<br><strong>针对问题二，</strong>技术栈不同，即异构组件的加载。目前来说frontend暂且只针对Vue组件做了异构兼容渲染，在React中使用Vue组件。一开始想到的是使用转换工具，将vue组件手动转换为React组件，之后再粘贴构建，但这种方式有个很大的缺陷：不同版本api差异较大，手动转码一般需要对转换过后的代码进行人工二次排查调整，需要开发人员对于两种框架的新老版本属性熟悉了解，对于不符合的代码或已更新的hooks等进行二次确认，无形中提高了使用门槛。<br>受到Docker容器的启发，思考React和Vue虽然属于不同的技术栈体系，但区别于Java和Golang的差异，Vue和React在本质上都是原生js对象的封装，所以理论上讲是可以在React中进行容器化渲染Vue组件的：即本质是绑定挂载Vue对象的操作：</p><div class="language-js codeBlockContainer_Ckt0 theme-code-block" style="--prism-color:#393A34;--prism-background-color:#f6f8fa"><div class="codeBlockContent_biex"><pre tabindex="0" class="prism-code language-js codeBlock_bY9V thin-scrollbar"><code class="codeBlockLines_e6Vv"><span class="token-line" style="color:#393A34"><span class="token plain" style="display:inline-block"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token function" style="color:#d73a49">createVueInstance</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token parameter">targetElement</span><span class="token parameter punctuation" style="color:#393A34">,</span><span class="token parameter"> reactThisBinding</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token keyword" style="color:#00009f">const</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"> component</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> on</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token spread operator" style="color:#393A34">...</span><span class="token plain">props </span><span class="token punctuation" style="color:#393A34">}</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> reactThisBinding</span><span class="token punctuation" style="color:#393A34">.</span><span class="token property-access">props</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  reactThisBinding</span><span class="token punctuation" style="color:#393A34">.</span><span class="token property-access">vueInstance</span><span class="token plain"> </span><span class="token operator" style="color:#393A34">=</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">new</span><span class="token plain"> </span><span class="token class-name">Vue</span><span class="token punctuation" style="color:#393A34">(</span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token literal-property property" style="color:#36acaa">el</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> targetElement</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token literal-property property" style="color:#36acaa">data</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> props</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token spread operator" style="color:#393A34">...</span><span class="token plain">config</span><span class="token punctuation" style="color:#393A34">.</span><span class="token property-access">vueInstanceOptions</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token function" style="color:#d73a49">render</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">(</span><span class="token parameter">createElement</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token keyword control-flow" style="color:#00009f">return</span><span class="token plain"> </span><span class="token function" style="color:#d73a49">createElement</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token constant" style="color:#36acaa">VUE_COMPONENT_NAME</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          </span><span class="token literal-property property" style="color:#36acaa">props</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">this</span><span class="token punctuation" style="color:#393A34">.</span><span class="token property-access">$data</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">          on</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">        </span><span class="token punctuation" style="color:#393A34">[</span><span class="token function" style="color:#d73a49">wrapReactChildren</span><span class="token punctuation" style="color:#393A34">(</span><span class="token plain">createElement</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"> </span><span class="token keyword" style="color:#00009f">this</span><span class="token punctuation" style="color:#393A34">.</span><span class="token property-access">children</span><span class="token punctuation" style="color:#393A34">)</span><span class="token punctuation" style="color:#393A34">]</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token literal-property property" style="color:#36acaa">components</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token punctuation" style="color:#393A34">{</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token punctuation" style="color:#393A34">[</span><span class="token constant" style="color:#36acaa">VUE_COMPONENT_NAME</span><span class="token punctuation" style="color:#393A34">]</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> component</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">      </span><span class="token string-property property" style="color:#36acaa">'vuera-internal-react-wrapper'</span><span class="token operator" style="color:#393A34">:</span><span class="token plain"> </span><span class="token maybe-class-name">ReactWrapper</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">    </span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">,</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain">  </span><span class="token punctuation" style="color:#393A34">}</span><span class="token punctuation" style="color:#393A34">)</span><span class="token plain"></span><br></span><span class="token-line" style="color:#393A34"><span class="token plain"></span><span class="token punctuation" style="color:#393A34">}</span><br></span></code></pre><div class="buttonGroup__atx"><button type="button" aria-label="复制代码到剪贴板" title="复制" class="clean-btn"><span class="copyButtonIcons_eSgA" aria-hidden="true"><svg class="copyButtonIcon_y97N" viewBox="0 0 24 24"><path d="M19,21H8V7H19M19,5H8A2,2 0 0,0 6,7V21A2,2 0 0,0 8,23H19A2,2 0 0,0 21,21V7A2,2 0 0,0 19,5M16,1H4A2,2 0 0,0 2,3V17H4V3H16V1Z"></path></svg><svg class="copyButtonSuccessIcon_LjdS" viewBox="0 0 24 24"><path d="M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z"></path></svg></span></button></div></div></div><p>通过frontend远程组件脚手架@sreworks/widget-cli,对React组件和Vue组件进行打包并发布到cdn，然后在物料开发处，进行编辑即可便捷进行远程组件runtime加载和移除，解决了问题一和问题二，达成了“<strong>扩展性</strong>”和“<strong>可插拔</strong>”的目标。</p><a name="NRAuE"></a><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="演进总结">演进总结<a class="hash-link" href="#演进总结" title="标题的直接链接">​</a></h2><p>到这里，基本解决了开篇列举的一系列问题，为构建前端运维组件生态铺设好了共建路径，可以做到：</p><ul><li>从@sreworks/widgets包开发，JSXRender自定义组件，使用@sreworks/widget-cli开发远程组件三个维度扩展组件应用丰富度</li><li>更加清晰的结构依赖关系，降低学习和贡献参与这套低代码工程的门槛</li><li>以更小粒度的更新单元，更短的构建时间，便捷日常协作开发</li><li>子包拆分后，为后续小规模分步引入TS提供了条件</li></ul><a name="Tsxbb"></a><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="版本动态">版本动态<a class="hash-link" href="#版本动态" title="标题的直接链接">​</a></h2><p>我们会根据工作项目节奏，持续对功能进行完善优化和升级，当前主要是前端低代码功能的输出，后续API低代码编辑编排已纳入版本规划，以覆盖全链路低代码使用，大家有比较好的建议欢迎多提issue，同时也欢迎更多的开发者能够参与到我们的生态建设中来(@小助手，也可以直接前端@地谦)<br>SREWorks开源地址：<br><a href="https://github.com/alibaba/sreworks/paas/frontend" target="_blank" rel="noopener noreferrer">https://github.com/alibaba/sreworks/paas/frontend</a><br>也欢迎各位加入钉钉群（群号：35853026）分享和交流～</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[QCon演讲实录（下）：多云管理关键能力实现与解析-AppManager]]></title>
        <id>/caksc1spli40h2s5</id>
        <link href="https://sreworks.opensource.alibaba.com/column/caksc1spli40h2s5"/>
        <updated>2023-05-30T05:20:14.000Z</updated>
        <summary type="html"><![CDATA[在上篇中，我们已经基本了解了多云管理。现在，我们将深入探讨多云管理关键能力实现：AppManager。]]></summary>
        <content type="html"><![CDATA[<p>在上篇中，我们已经基本了解了多云管理。现在，我们将深入探讨多云管理关键能力实现：<strong>AppManager</strong>。</p><a name="TLCyM"></a><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="什么是appmanager"><strong>什么是AppManager？</strong><a class="hash-link" href="#什么是appmanager" title="标题的直接链接">​</a></h3><p>上面我们讲了理论、我们自己使用的交付流程和整体架构，下面我们进入关键能力实现与解析的环节，看看我们是如何实现上述这些能力的。<br><img loading="lazy" alt="image.png" src="/assets/images/1685424038808-cee9ddc8-dfbe-45b9-af3b-0df33ec40289-974943211ef735ed9247c3c4fcb31244.png" width="2218" height="956" class="img_ev3q"><br>回到 AppManager 这个服务本身，它就是一个基于 OAM 的几种分离的角色，能够实现应用管理及交付的一个服务。<br>它因大数据侧业务诉求而生长，注重扩展能力、网络隔离环境交付、资源管理和版本管理。</p><a name="bLdV0"></a><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="扩展能力"><strong>扩展能力</strong><a class="hash-link" href="#扩展能力" title="标题的直接链接">​</a></h3><p>首先来看最重要的扩展能力。不管在一开始的平台设计的时候有多么完善，都很难满足后续持续演进的业务需求。所以扩展性是一个 PaaS 平台的重中之重。<br><img loading="lazy" alt="image.png" src="/assets/images/1685424039680-9045ddad-4f1e-4dfc-92c4-ceacfb6c8bce-a0320289dbcdfdba81053367766cde65.png" width="1962" height="1180" class="img_ev3q"></p><p>依托于 OAM 的设计，我们将所有的 Component / Addon / Trait / Policy / Workflow 等均做成了可插拔动态加载的 Groovy 脚本，并在此之上提供了插件管理及市场分发的能力。<br>图中的所有绿色的地方都是可根据业务需要自行扩展的，所有能力都可以在整个流程中动态引入、插拔和替换。<br>最上面基础设施研发的同学负责编写支持的组件类型、工作流类型、资源类型的 Groovy 脚本，并注册到 AppManager 内部。<br>中间的 SRE 同学负责编写 Trait、Policy 的 Groovy 脚本注册到 AppManager 内部，并负责配置环境及部署约束条件等信息。<br>下面的用户只需要把自己的应用代码写好，然后按照预先定义的 CI、CD、Watch 流程运行即可。<br>三类角色各司其职，共同高效的完成多云环境下整体应用的管理与交付过程。<br>图中所有绿色的地方扩展的 Groovy 脚本都是去实现预先定义的 Interface 抽象接口的，任何实现了这些 Interface 的 Groovy 脚本，都可以像搭积木一样被组装和替换到各个应用的生命周期中发挥自己的能力。包括构建、部署、销毁、状态监测。<br>在服务内部，我们为每个脚本定义了自己的 kind (类型) / name (名称) / revision (版本) 三元组，全局唯一。对于相同的 kind + name 组合，仅加载指定的单个版本的代码版本。通过这样的设计，实现不同用途，不同名称的脚本动态加载，且可以自由切换脚本代码版本。</p><a name="H4ImB"></a><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="扩展能力--插件包"><strong>扩展能力 – 插件包</strong><a class="hash-link" href="#扩展能力--插件包" title="标题的直接链接">​</a></h3><p>虽然单个 Groovy 扩展方便且灵活，但不易分发，而开源版本 SREWorks 中社区用户的需求又千差万别，所以在此之上，我们增加了插件包的机制，插件包通过对一系列 Groovy 脚本的组合，实现对应功能的封装。用户只需要一键下载及安装即可实现对应的能力加载。<br><img loading="lazy" alt="image.png" src="/assets/images/1685424039611-7c34ca33-300e-48e6-a209-fa64fd0961d6-ba60b7a7bb4a61a1308751d6331d5cfd.png" width="3032" height="942" class="img_ev3q"><br>对于插件包本身，我们也定义了一套规范，用于社区用户进行二次开发编写自己需要的插件并上传到插件市场。<br><img loading="lazy" alt="image.png" src="/assets/images/1685424039154-e61a263f-b8d1-4a93-b36e-c320a6bdffd4-11b0c0f7d2bfd287b254fdf870c42152.png" width="3032" height="762" class="img_ev3q"></p><a name="hM8kp"></a><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="构建打包"><strong>构建打包</strong><a class="hash-link" href="#构建打包" title="标题的直接链接">​</a></h3><p>如果我们回顾过去这些年来的交付介质演进，可以看到抽象层次是越来越高的。从最开始的 RPM 等系统层面的软件包，到 Docker 出现后的镜像，再到后面以镜像为基础，进行各种包装而产生的交付物，如 Helm Chart/Kustomize 等。<br>那么我们也不例外，在物理机时代，我们作为 SRE 去维护各种物理机的软件一致性以及在此之上交付各类服务，甚至还研发了配套的流程平台、作业平台、配置平台等等。在 Docker 普及之后，这项工作就简单了很多，只需要处理镜像即可，但镜像本身的管理及交付仍然是头疼的问题。<br>好在现在是云原生的时代，我们有各类 CRD+Operator，有完善及可靠的 Kubernetes 原语，更有事实上的打包交付的标准 Helm/Kustomize 来帮助我们更好的完成交付物的封装。接下来我们就看一下，我们在整个应用交付的流程中，如何处理好构建打包、制品管理及外部 CI 对接的。<br><img loading="lazy" alt="image.png" src="/assets/images/1685424038929-c1ded81f-4064-471f-9942-2f9917a50197-cfde94c7044febcbae4c353bfca49855.png" width="2202" height="1174" class="img_ev3q"><br>通过图上我们可以看到，首先用户自定义的构建配置被提交，之后会被 AppManager 解析为应用包任务以及一个个的组件包任务，每个组件包任务会根据自己的组件类型选择对应的构建逻辑进行构建，这里可以有不同的数据源，也可以通过不同的方式产出镜像，不管是 Docker Daemon 还是 Kaniko 的方式都支持，也会推送到指定的镜像仓库中。最终完成后生成一个个组件包，以及拼装为一个应用包，赋予版本及标签后，最后上传到 OSS 或 MinIO 上进行制品存储。一个常见的用户场景是，通过标签声明当前制品的用途，在实际使用的时候通过标签进行过滤，并进而选择自己需要的版本号以确认唯一的制品。<br>当存在外部 CI 系统需要对接的时候，只需要将外部 CI 系统产出的镜像及其他 commit 信息通过 Trigger API 触发即可，后面的流程和上述人工主动触发一致。</p><a name="flpyO"></a><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="应用部署"><strong>应用部署</strong><a class="hash-link" href="#应用部署" title="标题的直接链接">​</a></h3><p>当获取到制品之后，就来到了整个系统中最核心也是最复杂的部分：应用部署。此处暂时先忽略多环境下的制品下发及相关细节，后面会单独讲到。现在先假设我们已经将制品传输到了指定环境中，并且镜像也已经在对应环境中可用，只是单纯的执行一次部署流程，会有哪些事情发生。<br>首先看一下整个 Application 的 Yaml，它完整定义了一个应用部署的模型，描述了一个应用应如何可靠而又灵活的交付到目标环境中。如前面所说，Component/Addon/Trait 为面向终态设计，Policy/Workflow 为面向过程设计。<br><img loading="lazy" alt="image.png" src="/assets/images/1685424042876-be51a6c9-be1c-4314-b7dc-f1af9a456e58-394e958424abd658222acbb8895f4742.png" width="1848" height="1578" class="img_ev3q"><br>之后来看一下整体的部署层级关系，从大到小分别是 Workflow 部署、Application 部署、Component 部署(含 Trait 部署)。当然并不局限于这三层，Workflow 是可以按业务需求进行各种嵌套的，后面会单独讲到。接下来我们用相反的顺序来介绍实现细节，自底向上，逐步拼出来我们最后的实现方案。</p><a name="ZzRl5"></a><h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="应用部署---trait">应用部署 - Trait<a class="hash-link" href="#应用部署---trait" title="标题的直接链接">​</a></h4><p>Trait 我们会归类为三种功能：</p><ul><li>根据配置修改绑定的 Component Workload Yaml。</li><li>新增 / 修改资源 / 做你想做的事，并在完成后产出数据给自身对应的组件或后续其他组件使用。</li><li>持续监听目标集群中当前组件的事件（不只是部署过程中），并实时根据事件做出反应（Groovy 实现），常用于根据组件的当前状态做出一些外部反应，比如 Pod 漂移 IP 变动后需要重新做一些信息注册或维护类的工作。</li></ul><p><img loading="lazy" alt="image.png" src="/assets/images/1685424042693-a3a3b0d5-633f-4d33-af5d-792165faaff8-930ba64dac45fb008effe6815202ce60.png" width="2302" height="1080" class="img_ev3q"><br>所有的 Trait 也都是 Groovy 脚本实现，并封装为插件包注册到系统中。每个 Trait Groovy 的 class 说明如上图，其中会包括两个 interface：</p><ul><li>一个是 execute，所有类型的 Trait 在部署过程中均会执行该方法，并产出数据供下游使用，当然产出数据是可选的</li><li>另外一个是 reconcile，只有第三类需要持续监听目标集群事件的 Trait 才会使用，本质上是目标集群运行着我们开发的一个 Trait Operator，在 execute 执行的时候下发一个监听 CR 到该集群，Trait Operator 检测到该 CR 后会启动一个新的 Controller 来监听指定组件事件，并在事件到来后直接调用 AppManager 的 Trait Reconcile API，该 API 会直接同步调用对应 Trait Groovy 脚本中的 reconcile 方法，完成业务自定义的事件触发动作。这里其实等价于我们把常见的 K8S Operator 的 Reconcile 链路延长到了 AppManager 自身，并通过 Groovy 来实现业务逻辑，简化了常规 Operator 的开发流程，并且中心化也更好维护一些，尤其是面对茫茫多的目标集群的时候。<a name="Wy1FM"></a></li></ul><h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="应用部署---组件">应用部署 - 组件<a class="hash-link" href="#应用部署---组件" title="标题的直接链接">​</a></h4><p>对于组件而言，我们定义了几个固定类型，分别是构建、部署和状态感知。其中构建前面介绍过了，状态感知是可选的，会在最后进行介绍。这里主要介绍下部署逻辑。<br>组件部署的时候，一样会执行对应的 Groovy 脚本，并且系统会在进入脚本执行前自动将选定的制品解压到本地目录供脚本使用，以执行业务自定义的部署逻辑。目前我们已经根据各个业务情况编写了 6 类内部使用的组件，这些因为和阿里云业务相关无法开源。在开源场景下，我们默认提供了微服务、Job、Helm 几种类型，并开放了扩展机制，供有需要的用户自行编写新的组件类型来控制自己的组件如何部署。这里的组件类型是抽象的，也可以完全和 K8S 无关，比如是自己公司内部系统的某些特定配置导入导出。<br><img loading="lazy" alt="image.png" src="/assets/images/1685424042723-2375d1a2-e7f0-44f1-bd14-a11658c92116-24d40334927a92c0486e4880f9f5e55a.png" width="2176" height="1046" class="img_ev3q"><br>由上面的图可以看到，在部署过程中，Groovy 脚本中的 launch 方法会首先被调用，并完成对应的部署流程，这里可通过 fabric8 进行 K8S 远程调用 apply 下去对应的 Yaml，当完成后立即返回即可。之后，AppManager 服务会不停轮询当前 Groovy 脚本中的 get 方法，期望查询到成功的返回值，否则就会一直等下去，直到超时或失败。<br>这里在检查业务组件终态的时候其实还可以和组件自身的状态感知的能力产生互动，比如一直没有终态，但是没有终态的原因是什么呢？是可以通过后面说的状态感知来分析失败原因并返回给用户的。后面我们再细讲。</p><a name="foZCH"></a><h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="应用部署--应用--组件--trait-间依赖关系"><strong>应用部署 – 应用 &amp; 组件 &amp; Trait 间依赖关系</strong><a class="hash-link" href="#应用部署--应用--组件--trait-间依赖关系" title="标题的直接链接">​</a></h4><p>说完了组件和 Trait 的部署，我们上升到应用层面，来看下在应用的视角下，自身的组件、Trait 在整个部署流程中的数据关系。<br>因为实际的业务场景中，每个组件和 Trait 都有可能产生数据输出，并且会被别的组件和 Trait 引用到，在这种依赖关系下，产出数据的组件不跑完，引用数据的组件是不能跑的。但如果两个组件间没有任何依赖关系，那么他们是需要并行跑来提速的。<br><img loading="lazy" alt="image.png" src="/assets/images/1685424043217-d622e6b4-5baf-4f53-8c30-f00104532ad3-6c2280b4e6795e116e6276544991fef3.png" width="2108" height="1344" class="img_ev3q"><br>所以按照 OAM spec 的描述，我们在 Application Yaml 中为每个组件和 Trait 都提供了 dataInputs 和 dataOutputs 能力，如图上的 Yaml 所示。<br>在 AppManager 系统收到上面的 Yaml 后，在整个应用部署的过程中就需要对针对所有的组件和 Trait 之间的关系建图连边了。<br><img loading="lazy" alt="image.png" src="/assets/images/1685424044202-07da8c4c-b35a-4a84-a5f4-8d1ea5208843-965f93ca8a1263bac2a4e59b6f034d1d.png" width="2954" height="1626" class="img_ev3q"><br>在构图的时候，Component 和 Trait 是一视同仁的，这种对等关系会降低复杂度，同时保证数据流依赖关系在两种类型上保持一致。<br>对于每个 Component，会单独再构造一个镜像节点，用于确保前置组件的后置 Trait 节点的运行在当前组件之前。这样整体构图之后，只需要按照这个 DAG 无脑执行即可满足约束顺序。</p><a name="StmTk"></a><h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="应用部署--workflow"><strong>应用部署 -Workflow</strong><a class="hash-link" href="#应用部署--workflow" title="标题的直接链接">​</a></h4><p>在早期的业务支撑中，其实是没有 Workflow &amp; Policy 这一层的，但是上面讲到的应用部署只是针对单目标的，如果是批量目标环境的部署，就需要在更高的纬度发起多个应用部署单子来解决。</p><p>OAM 针对这一情况也在 0.3.1 的草案中提出了解决方案，也就是 Workflow &amp; Policy。这里简要说明一下：</p><ul><li>一个 Workflow 包含多个步骤，执行顺序可以顺次，也可以并发，如果并发的话就是按照上面说的 dataInputs/dataOutputs 的 DAG 构造方式。</li><li>每个 Workflow Step 也都是 Groovy 脚本来实现，所以每个步骤执行什么，怎样执行全部交给平台方来定义。</li><li>每个 Workflow Step 的 Groovy 脚本中，可以调用 Policy 对全局 Application 进行自定义修改，并且将修改后的 Application 提交应用部署单，也就是前面说的逻辑，这样就可以实现不同目标环境有不同的覆写配置。</li><li>Workflow 在执行的过程中可以有更多的控制及人工介入，如暂停、恢复、设置上下文等等，在灰度发布场景、涉及回滚动作的时候尤其有用。</li><li>Workflow Step 可以继续产出一个 Workflow，实现复杂场景实现套娃效果。<a name="ef2Nn"></a></li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="资源管理addon"><strong>资源管理（Addon）</strong><a class="hash-link" href="#资源管理addon" title="标题的直接链接">​</a></h3><p>秉承着所有可扩展的东西都通过 Groovy 脚本来插拔，资源 Addon 也不例外，其实也可以把它看做是 Component 组件。<br>对于 Addon，会有和 Component 不同的语义。资源需要申请和释放，也就是 apply 和 release，所以这两个方法是 Addon 层面的 interface。同时 Addon 也会存在自己的规格 Schema 定义，前端会在资源申请的时候识别这个定义，让用户在页面选择需要申请的资源规格（比如 8c16g 的数据库）。<br>在我们的实践过程中，直接写了一个对接 Terraform 的 Groovy 脚本就完成了大部分的内部业务诉求。对于所有的 tfstate 文件也会透出以 Addon Schema 的形式存储到数据库中供后续其他组件使用或共享。<br><img loading="lazy" alt="image.png" src="/assets/images/1685424045082-df3a5d98-e5ac-429b-b279-c48f623fa436-2d7c9e18145f60da07dc5ed97ffe573b.png" width="2362" height="1046" class="img_ev3q"><br>注意资源的特性是应用下根据 Namespace 隔离的，但 Namespace 下的同名资源会进行共享。一个典型的场景是生产的 Namespace 下申请的数据库会共享到预发和生产两个环境的服务中。这里在下一页的多环境支持中进行介绍。<br>如果你对于其他第三方的各类异构资源有需求，比如有的资源需要通过特定的 API 申请的，完全可以再扩展一个插件注册进去即可实现。</p><a name="FaJMj"></a><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="-多环境支持"><strong> 多环境支持</strong><a class="hash-link" href="#-多环境支持" title="标题的直接链接">​</a></h3><p><img loading="lazy" alt="image.png" src="/assets/images/1685424045480-e2f54b1e-d962-458a-8e75-d8dbbf1b79b9-dffb63d38fea3beed82abedea11b5a16.png" width="1146" height="612" class="img_ev3q"><br>我们在 AppManager 中定义了四种环境层级，如上图。从上到下分别是：</p><ul><li>Unit(单元)：单元间网络隔离。每个单元需要一个 AppManager 实例进行管控。一个单元可包括多个 Cluster。</li><li>Cluster(集群):一个独立 K8S 集群，集群间网络可达。集群直接注册 kubeconfig 到当前单元下的 AppManager 即可使用。</li><li>Namespace(命名空间): 对应 K8S 的 Namespace 概念，用于一个 Cluster 下的资源及应用的隔离，一个 Namespace 对应了一个信息孤岛。</li><li>Stage(阶段/环境): 一个 Namespace 可包含多个 Stage，每个 Stage 共享了当前 Namespace 下的所有资源。<a name="kwnjg"></a></li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="应用状态感知"><strong>应用状态感知</strong><a class="hash-link" href="#应用状态感知" title="标题的直接链接">​</a></h3><p>一个应用被交付到目标环境之后，运行的状态怎么样？这块其实有很多种外部开源方案或监控手段可以来搞的，不展开。这里只介绍下 AppManager 内置的一个简单的状态感知方案。<br><img loading="lazy" alt="image.png" src="/assets/images/1685424045714-ffef724e-6ed8-45e9-a624-968866b901b5-e70bb4160c06361eacf1cfdcc33661bf.png" width="1642" height="992" class="img_ev3q"><br>由上图可以看到，一个应用被部署到了一个目标环境中，就变成了一个应用实例 Application Instance。一个组件被部署后也一样会变成组件实例 Component Instance。应用实例的状态是由组件实例的状态汇聚而来的，那么组件实例的状态需要怎么来呢？<br>首先来看 Watch 的方案，时效性高，但支撑的集群数量只有几百个，小规模下使用。本质上是在组件注册的时候通过 Informer 机制 List/Watch 集群事件，然后将 Event Handler 的实现交由组件开发者自己自行判断，并根据内容返回业务自定义的状态结果。<br><img loading="lazy" alt="image.png" src="/assets/images/1685424046147-d6e4a5eb-06eb-471c-9b72-5da9e7d36631-51523edba130d448cb29373f986259cb.png" width="2260" height="1096" class="img_ev3q"><br>接下来是 Pull 方案，可以支撑最高 10 万量级的应用及集群，但时效性在应用状态正常时会逐步降低到 5min。只有在发生异常时会快速提升检测频率，直到再次恢复正常。当然具体的状态判定的脚本也是交给组件开发者来写的，可以根据业务需要自行扩展，灵活性非常高。<img loading="lazy" alt="image.png" src="/assets/images/1685424047796-f2dc626d-8ba6-472c-b1f7-410f8a7cd53a-cc9a8eda1bfc366440a3e90a6c3dbd5d.png" width="2274" height="1112" class="img_ev3q"></p><p>以上为本次分享全部内容，谢谢大家的聆听。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[QCon演讲实录（上）：多云环境下应用管理与交付实践]]></title>
        <id>/cylt0vx8qc1g3973</id>
        <link href="https://sreworks.opensource.alibaba.com/column/cylt0vx8qc1g3973"/>
        <updated>2023-05-30T05:17:55.000Z</updated>
        <summary type="html"><![CDATA[大家上午好！我是来自阿里云大数据基础工程技术团队的郭耀星，花名雪尧。今天我很高兴能够来到QCon，与大家分享我的经验和心得。在当前的多云环境中，作为运维支撑团队，如何在分裂严重、存在多个不同环境的异构Kubernetes底座情况下，高效率地管理与交付业务应用，是一个值得探讨的话题。]]></summary>
        <content type="html"><![CDATA[<p>大家上午好！我是来自阿里云大数据基础工程技术团队的郭耀星，花名雪尧。今天我很高兴能够来到QCon，与大家分享我的经验和心得。<strong>在当前的多云环境中，作为运维支撑团队，如何在分裂严重、存在多个不同环境的异构Kubernetes底座情况下，高效率地管理与交付业务应用，是一个值得探讨的话题。</strong></p><p>在开始正式分享之前，先做一个简单的自我介绍，我是 17 年武汉大学毕业，之后一直在阿里云的计算平台大数据基础工程技术团队，从事大数据运维平台的研发工作，也算是见证了大数据运维平台持续迭代演进的过程。</p><p>在我刚入职之后，我负责过多个运维中台服务的开发和建设。后来随着大数据架构从物理机向云化转变，我逐步开始从事容器化相关的改造，再到现在完全是云原生的天下。在这个过程中，我主导了我们这边的 ABM，也就是大数据运维平台，在专有云及公共云上，几十个应用从物理机到 on K8S 的转型，这个过程很痛苦，但也以此为契机，沉淀出了一套多云环境下的云原生下应用管理与交付的服务以及相对应的实践经验，期望在接下来的时间里与大家分享。</p><p><strong>今天我分享的内容主要有四个部分：</strong></p><ul><li><strong>多云环境应用管理与交付痛点</strong></li><li><strong>理论先行：OAM</strong></li><li><strong>多云环境交付实践 - 微服务 / 大数据产品 / SREWorks开源社区</strong></li><li><strong>关键能力实现与解析：AppManager (OAM Runtime)</strong></li></ul><p><strong>首先来介绍多云环境下应用管理与交付的痛点，然后看在这些痛点之上，我们为什么选择了 OAM 作为我们的理论模型，以及基于这套理论模型，我们在多个业务场景下的实践经验，最后是我们自己研发的这套 AppManager 服务关键能力的实现方案与解析。</strong></p><a name="VvPQo"></a><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="多云环境应用管理与交付痛点">多云环境应用管理与交付痛点<a class="hash-link" href="#多云环境应用管理与交付痛点" title="标题的直接链接">​</a></h2><a name="FylBC"></a><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="痛点-1--多云环境下的-k8s-底座适配问题">痛点 1 – 多云环境下的 K8s 底座适配问题<a class="hash-link" href="#痛点-1--多云环境下的-k8s-底座适配问题" title="标题的直接链接">​</a></h3><p>首先是第一部分，多云环境下，应用管理与交付的痛点是什么？<br>由于在统一底层基础架构细节方面的出色表现，K8S 已经成为企业多云管理的事实基础。但单服务商的单 K8S 集群真的满足需求么？<br>答案是否定的，作为基础设施的运维，我们会和形形色色的 K8S 集群打交道。有当前已有的各个厂商提供的公共云 K8S 集群，也有专有云版本部署在网络隔离机房环境下的 K8S 集群，以及单独拿出来做日常开发测试的 K8S 集群等等。除此之外，在阿里的内部场景还有更多的虚拟 K8S 集群，比如 Flink 全托管场景等。<br><img loading="lazy" alt="image.png" src="/assets/images/1685423948618-f97895d5-61cc-42e0-b88a-4f14eff07725-8862a1e169e84071081318858eba9411.png" width="1228" height="1440" class="img_ev3q"><br>一般来说，大家常见的诉求是：</p><ul><li>需要物理隔离，避免业务间相互影响。尽管 K8S 自身提供了 Namespace 级别的隔离，你可以设置每个 Namespace 各自使用的 CPU 和内存，甚至可以使用 Network Policy 配置不同 Namespace 的网络连通性，但这些仍然不彻底，企业还是需要一个更加彻底的物理隔离环境，以此避免业务之间的互相影响。</li><li>需要混合云。混合云场景下，企业希望可以选择多个公有云厂商和私有云解决方案，避免受限于单一云厂商，或降低一定成本。</li><li>需要应用异地多活。部署业务多个副本到不同 region 集群，避免单个 region 的断电造成应用的不可用情况，实现不把鸡蛋放在同一个篮子目的。</li><li>需要环境分离。为了区分开发测试生产环境，把这些环境部署到不同的集群。</li><li>需要一定的集群拓展性来突破单一集群的容量上限。</li></ul><p>当然从纯粹的多集群视角来看，目前方案有 Federation V1 / Federation V2 / OCM 等解决方案，还有多个 kubeconfig 直连的方式。不过这块不是本次讨论的重点，这里并不讨论多集群的问题，而是讨论异构 K8S 底座，多集群方案可以看做是异构 K8S 底座方案的一个子集。<br>所以最后重点是：如何在一个分裂的非常严重的，位于多个不同环境的异构 K8S 底座下，高效率的进行应用管理与交付。</p><a name="tJIdE"></a><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="痛点-2--研发与运维的诉求冲突">痛点 2 – 研发与运维的诉求冲突<a class="hash-link" href="#痛点-2--研发与运维的诉求冲突" title="标题的直接链接">​</a></h3><p>我们团队自身其实定位于运维平台开发，上面会有两类角色，一类是研发，一类是 SRE。在更小规模的公司体量下，运维开发和 SRE 会归为一体，对研发提供运维平台及服务。<br><img loading="lazy" alt="image.png" src="/assets/images/1685423947730-82dc3369-a49c-4346-ab29-1927c21d902c-b0c061144a9779198172b4011454a9c6.png" width="2270" height="1244" class="img_ev3q"><br>当一个人的时候，我们推崇全栈工程师，DevOps。但随着规模和体量越来越大，一定会出现很多责任田，归属到不同的团队和不同的人。<br>在上述演进的过程中，研发和运维之间的矛盾会愈发凸显：在研发及产品视角，疯狂迭代疯狂上功能才能拿下用户拿下市场；在运维视角，不动线上不做变更就不会出问题。</p><a name="WixhP"></a><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="痛点-3--研发与运维的分工冲突"><strong>痛点 3 – 研发与运维的分工冲突</strong><a class="hash-link" href="#痛点-3--研发与运维的分工冲突" title="标题的直接链接">​</a></h3><p>在物理机/ECS时代，我们自身控制着从下到上的整个链路。为了调和上述矛盾，我们制定了各种各样的变更规范，开发了各式各样的变更工具和流程，当然也吵过了很多的架。<br><img loading="lazy" alt="image.png" src="/assets/images/1685423948780-b2ad6c47-69ea-4fce-b16d-000aa913701c-f61ccd5df13874f2209ffb4bda8f9de8.png" width="2156" height="1148" class="img_ev3q"></p><p>那么在云原生的浪潮之下，Kubernetes 统一了底层的基础设施，减少了大部分的底层运维工作，大家开玩笑说全部变成了 YAML 工程师。但还是有一个很重要的问题没有解决，就是：YAML怎么写？谁来写？如何交付到目标 K8S 集群？<br>过去的两年多的时间里，上面这些问题实实在在地摆在了我们团队的面前，在当前的定位与场景下，要支持专有云、公共云、集团内部、开源社区等环境下的形形色色各式各样的 K8S 集群上面的服务托管与交付。</p><a name="eEke8"></a><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="理论先行oam">理论先行：OAM<a class="hash-link" href="#理论先行oam" title="标题的直接链接">​</a></h2><p>古时候有兵马未动，粮草先行。这里我们是代码未动，理论先行。先说一下我们为什么会选择 OAM(Open Application Model) 作为我们解决问题的理论基础。<br>我们上面讨论了多种多样的痛点后，基本可以总结下面几点：</p><ul><li>一个是开发者花费了太多的时间在基础设施的细节中。机器从哪来，网络环境怎么样，中间件资源/DNS/负载均衡怎么生成，集团内部的服务怎么适配到公共云/专有云各个底座上等等。或者更进一步，每个开发者都是 Yaml 工程师，哪怕都是 K8S，但每个底座让你提交的 YAML 都不一样。</li><li>另外一个是可扩展性低。有越来越多的平台 or 底座在尝试去支撑各种类型需求的业务，但一般来说，应用本身对于平台的诉求会很快超越平台的能力。</li><li>还有云服务供应商绑定。当选择了一个固定的底座后，应用交付的方方面面将会打上这个底座的烙印，当想尝试转到另一个底座的时候难于登天。</li><li>最后是随着团队规模的膨胀，研发、运维、平台人员之间开始各种相互踩脚，沟通和协调的成本也越来越高。</li></ul><p>OAM 针对上述痛点提出了以下几个观点：</p><ul><li>应用为先：一个应用的交付与部署应该是自包含的，其中的各类操作行为应该作为应用定义的一部分，这些内容与实际基础设施无关。</li><li>清晰和可扩展性：定义一套开放标准，可以模块化整个应用交付流程，根据个人需要将这些模块自由组装，达成自己想要的结果。</li><li>云服务供应商无关：定义的开放标准应该是一套更高级别的抽象，可以跨本地集群、跨云服务供应商，不会被锁定到任何一个厂商的底座。</li></ul><p><img loading="lazy" alt="image.png" src="/assets/images/1685423949106-185d411a-1324-4e38-a0d2-10b71983f061-65c0d4e261cfee88966a115eb83d304c.png" width="1972" height="1618" class="img_ev3q"><br>OAM 通过一系列概念的定义，完成了对一个应用的抽象，实现了角色职责的分离，将应用交付这件事情与底座解耦，使得跨云快速交付应用成为可能。开发同学也不再关心底座实现细节，只关心自己的应用模型即可。OAM 的诞生，旨在定义云原生应用标准。</p><p>接下来我们简单介绍下 OAM 中的部分概念：<br><img loading="lazy" alt="image.png" src="/assets/images/1685423947182-4f839145-1be1-4a65-bcee-a55c280b9ed1-73be347c22b8a92af9886346d4ce51c5.png" width="1048" height="590" class="img_ev3q"></p><p>一个 Application，也就是上图中最外面的蓝框，代表一个应用，是包含多个组件 Component 的，这里的组件就是我们日常交付的最小业务单元，也就是上图中的浅绿色部分，比如一个微服务、一个 Job、一个 Helm 包等。那么组件 Component 的内部是由蓝色的 Workload 和深绿色的 Trait 组成的。Workload 就是工作负载类型，描述了当前 Component 是谁，而 Trait 则定义了当前组件的运维属性，比如我需要给这个微服务加个 200G 存储，加一条网关路由，限制多少 CPU 内存资源，或者更复杂一点，当 Pod 漂移后 IP 变动了去做一些外部数据维护的事情。上面我描述的这些都可以用 Trait 来抽象及描述。<br>上面说的这几个概念，都是面向终态的，和 K8S 自身的面向终态的逻辑是一致的，我只需要声明式的写出我希望的实际交付后的应用的样子，而不需要关心内部是怎么 Reconcile（调和） 去实现的。<br><img loading="lazy" alt="image.png" src="/assets/images/1685423949262-585b3769-f9ec-480c-b4a4-abe9fea1acbb-2610bce2bfc26abcfe8dec9ee5948dd2.png" width="1048" height="590" class="img_ev3q"></p><p>除此之外，还有工作流 Workflow 和应用执行策略 Policy 的概念作为补充，他们是面向过程的，用于解决单纯的面向终态的声明方式无法覆盖的交付过程控制，比如人工审核、回滚、多集群发布等等。<br>我认为 OAM 模型带给我们的最大影响是，我们需要时时刻刻将“关注点分离”这个事情作为最大的准则，简单来说就是明确人员分工。这里面有三个角色：</p><ul><li>第一个角色是应用开发人员，也就是写业务代码的同学，他们只需要负责组件 Component 的定义，比如我是什么类型的服务，镜像怎么构建，需要哪些参数来启动运行。</li><li>第二个角色是应用运维人员，他们定义上面讲到的运维特征，也就是 Trait，并将应用开发人员定义好的 Component 和这些 Trait 绑定到一起，辅以 Policy + Workflow，来生成最终交付的 Application YAML，并提交到 Runtime 实现，去维护整个应用的生命周期。</li><li>最后一个角色是基础设施运维人员，他们去控制整个平台有哪些 Workload 可供上面两类角色使用，以及维护整个平台层面的稳定性。</li></ul><p>当然在实际实践的过程中，根据团队规模，有可能一人身兼数职，但随着团队规模的扩大，按上面的描述进行团队的分工，可以最大限度的降低沟通协作的成本，提高应用管理与交付的效率及稳定性。</p><a name="q5YiM"></a><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="多云环境交付实践">多云环境交付实践<a class="hash-link" href="#多云环境交付实践" title="标题的直接链接">​</a></h2><p>终于讲完了理论，我们接下来进入实践环节。<br>先简要描述下我们的团队所面临的业务场景，有四大块，分别是专有云、公共云、集团内部还有开源社区：</p><ul><li><strong>专有云</strong>：将 ABM 交付到各个客户现场环境中，依赖统一的阿里专有云 K8s 底座。大部分的客户环境是网络隔离的，不出差到现场的情况下，只能拍照一来一回解决问题。</li><li><strong>公共云</strong>：交付各个阿里大数据产品到公共云 ACK 集群上(资源集群 or 业务集群)，多 Region，为云上客户提供服务。</li><li><strong>集团内部</strong>：部署各个大数据产品到集团内部 K8S 集群上，多 Region，为集团内部各业务方提供服务；另外还需要将我们自身交付到 OXS(阿里云内核区域)K8s 公共集群中 (权限受限)。</li><li><strong>开源社区</strong>：交付 SREWorks 到各类用户自建的集群下以及各大厂商公共云。</li></ul><a name="Q105b"></a><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="产品形态">产品形态<a class="hash-link" href="#产品形态" title="标题的直接链接">​</a></h3><p>面对上面所说的复杂多云环境，我们最终设计的产品架构如下：<br><img loading="lazy" alt="image.png" src="/assets/images/1685423950259-241c465b-49cf-4393-ba1e-0285257b12ec-3fce70eb5f6d575aa949ba8f3460ea8a.png" width="2102" height="1120" class="img_ev3q"></p><p>大家可以看到，我们针对于多云下的应用管理和交付场景，自研了一套基于 OAM 模型的  AppManager 服务，可以认为是一套 OAM 模型的 Java Runtime 实现。它作为应用引擎，提供了很多能力，涵盖构建、部署、制品管理、工作流引擎、插件、多云支持、多环境支持、状态感知等等，提供底层能力并向上暴露 API。在此之上，我们针对三个场景提供了对应的用户界面，并对实际用户提供服务。</p><ul><li>首先是企业应用管理：各类开源/自有应用的云原生部署方案，可扩展各种组件类型，让使用者可以一键部署复杂应用支撑业务。</li><li>之后是运维应用管理，这里会细分一下：<ul><li>第一类是使用前端低代码模式构建的运维应用配置，能够被快速嵌入集成运维中台能力。此类应用无实际后端，均为纯粹的应用配置集合。</li><li>第二类是使用微服务类型构建的运维应用，能够识别并托管上面说的的应用配置，实现对应的运维中台能力。</li></ul></li><li>最后是大数据应用管理，对应开源场景 SREWorks 下的企业应用管理。在内部我们通过该系统实现阿里云上的所有大数据产品的交付、售卖及管控能力。</li></ul><p>为了更好的和外部互动，我们开源了 SREWorks，作为一整套数智化运维的解决方案，也就是上图中的 AppManager + 企业应用管理 + 运维应用管理，期望能为大家提供开箱即用的云原生应用 &amp; 资源交付的运维平台。大家感兴趣的可以去 Github 上进一步了解，一会儿会单独介绍。其中，AppManager 和我们内部使用的是同一套代码和分支，一直保持着和开源社区的同步；企业应用管理和运维应用管理经过一定剪裁和开源适配；而大数据应用管理因为涉及阿里云上各个大数据产品的交付、售卖及管控细节，暂不开源。</p><a name="sp7Xw"></a><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="微服务">微服务<a class="hash-link" href="#微服务" title="标题的直接链接">​</a></h3><p>接下来我们针对不同的业务类型来看一下整体的流程：<br><img loading="lazy" alt="image.png" src="/assets/images/1685423951424-50ef8a6a-cdbf-4ccd-b246-eb8aa5e900f7-29eaab45e37d5bc538f57c4097cea1ab.png" width="2184" height="1110" class="img_ev3q"><br>首先是最简单的微服务，通过 AppManager，研发的同学配置好自己的仓库和 Dockerfile，就可以自动构建出来对应的镜像，以及包装后的制品——微服务组件包，多个微服务组件包最终打包为一个独立带版本的应用包。<br>之后是 SRE 同学入场，通过选择研发同学提供的制品，配合自己配置的一系列交付参数，比如部署到哪些目标集群、需要针对每个集群设置什么参数、加上哪些运维特征 Trait、配置什么策略、用什么工作流来编排、如何监测感知应用运行状态等等，这些最终生成了一份 Application 的 Yaml 文件，提交到 AppManager 运行。之后会由 AppManager 解析上述 YAML 并按要求交付到各个环境中，完成整个多云环境下的应用交付过程。<br>另外在右下角这类专有云隔离环境下，我们还支持了离线包交付，方便在网络隔离的环境下仍然简单高效的交付全部的应用。</p><a name="EVrBc"></a><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="大数据产品">大数据产品<a class="hash-link" href="#大数据产品" title="标题的直接链接">​</a></h3><p>接下来看阿里云上售卖的大数据云产品的场景：<br><img loading="lazy" alt="image.png" src="/assets/images/1685423953196-561ee8c3-6981-419f-97c0-af3e19847319-7b58433ed1c6ab53f39be9ee50c586c1.png" width="2086" height="1160" class="img_ev3q"></p><p>大数据产品因为业务特性复杂，有大量的动态渲染及相互依赖关系，所以目前采用了我们内部自研的 AbmChart 组件类型来承载，还有通用的 Helm/Kustomize 两种形态，但不管采用哪种形态，都是 Component，在流程上和刚才并没有什么不同，都是构建、打包、交付、监测。只不过组件类型的内部处理流程较为复杂，以及交付的目标集群及形态多样化。</p><a name="V80yK"></a><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="sreworks开源社区">SREWorks开源社区<a class="hash-link" href="#sreworks开源社区" title="标题的直接链接">​</a></h3><p>最后是 SREWorks 开源社区，SREWorks 是我们团队对SRE理念的工程实践的一套开源产品。通过抽象通用运维模型，实现五大核心价值场景，包括智能化运维、数据化运维、云原生 DevOps、云原生运维开发、多云管理。支撑“质量、成本、效率、安全”的运维需求，提供“交付、监控、管理、控制、运营、服务”全生命周期能力支撑。<br><img loading="lazy" alt="image.png" src="/assets/images/1685423951981-af9251c9-bbd3-492c-a42d-461b28c83f6b-c187dc5f4b61a00ae96f59924f5eb5c4.png" width="1852" height="1158" class="img_ev3q"></p><a name="YPpVv"></a><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="统一管控方案">统一管控方案<a class="hash-link" href="#统一管控方案" title="标题的直接链接">​</a></h3><p>看完了应用管理及交付的流程，之后我们来看一下统一管控的方案：<br><img loading="lazy" alt="image.png" src="/assets/images/1685423954485-def5ecfc-3968-4529-8acc-974fb352a760-a2b89c42299dfd4fcaa5ed49a699a4ee.png" width="2478" height="1582" class="img_ev3q"></p><p>因为是多云环境，所以会需要一个中心环境 AppManager 服务来作为整体的管控，也就是中心绿色的部分。<br>我们把每一个网络隔离或用途隔离的环境称为一个单元 Unit，单元内自成一体，对外无任何依赖。<br>每个单元需要部署一个 AppManager 作为这个单元自己的管控，并负责自己这个单元下所有应用的交付动作。中心 AppManager 只负责向各个单元 AppManager 下发命令即可。<br>在这个管控架构下，我们目前有几种类型的单元，每个单元可以非常灵活地适配其底座架构部署。</p><p>鉴于本次演讲篇幅比较长，我们将演讲稿分为了上下两篇文章。在这上篇中，我们已经对多云管理有了一个基本的了解。在下篇中，我们将更深入地解析多云管理的关键能力：AppManager。</p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[当我们在谈论DataOps时，我们到底在谈论什么]]></title>
        <id>/barsmz880p6lg0vz</id>
        <link href="https://sreworks.opensource.alibaba.com/column/barsmz880p6lg0vz"/>
        <updated>2023-01-16T20:44:11.000Z</updated>
        <summary type="html"><![CDATA[1. DataOps到底是什么？]]></summary>
        <content type="html"><![CDATA[<a name="dxOcg"></a><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="1-dataops到底是什么">1. DataOps到底是什么？<a class="hash-link" href="#1-dataops到底是什么" title="标题的直接链接">​</a></h2><p>伴随着全球数字化转型的高速发展，在云计算、物联网、5G、边缘计算、元宇宙等新技术的驱动下，数据爆炸的时代已经来临。IDC Global DataSphere显示，2021年，全球数据总量达到了84.5ZB，预计到2026年，全球结构化与非结构化数据总量将达到221.2ZB。<br>此外，在《数字化转型架构：方法论和云原生实践》一书中也提到云原生应用平台的发展将经历DevOps—DataOps—AIOps的演进路径，可以看出在云原生的浪潮下，企业也越来越需要数据。但在面对数据量巨大、数据种类繁多、数据急剧增长的困境时，对企业驾驭数据的能力也提出更高的要求。如果不能对海量数据进行合理有序的组织和管理，非但不能产生数据价值，反而会对企业造成极大的负担，从某种程度上来说，也是一种“数据灾难”，而这也是DataOps一直处于热门话题的原因。在开源SREWorks项目数据化建设过程中，我们也一直在思考：DataOps到底是在做什么？<br>在讨论DataOps之前，我们先来看下DevOps。DevOps是一种软件交付管理的思想，它追求一种敏捷的、规范的、跨团队的软件研发协作状态，力求将一套软件的开发模式，从小作坊形态演变成一条标准的生产流水线。DevOps在一定程度上为DataOps的发展奠定了基础，因此，DevOps是我们在讨论DataOps时绕不开的重要话题。<br>DataOps本身也是属于敏捷开发范畴，类似DevOps以较短的开发迭代周期快速满足各自的需求，同时DataOps也需要大量标准化数据工具或组件，依赖团队之间协作，进行数据的开发和分析。与DevOps不同的是DataOps主要专注于数据流，<strong>因此，通过数据化的方法或方法论来推动企业运营水平的提升都可以隶属于DataOps的范畴。</strong></p><p><img loading="lazy" alt="The DataOps lifecycle （来源 The Rise of DataOps: Governance and Agility with TrueDataOps）" src="/assets/images/1673901865572-31e383be-4316-4043-8717-760df8131f47-716e327566c341f6bc1c03cd938dbaa6.png" width="1507" height="490" class="img_ev3q"></p><p>DataOps 是 data operationalization的缩写，DataOps 不单单指数据技术的工具和平台，更重要的是一套数据全生命周期管理的方法论和思想。基于数据驱动，通过一系列面向流程的工具和平台，将DataOps思想进行工程化落地实践，能够将所有系统的相关数据采集起来，打破数据孤岛，统一建设高效规范的数据模型和数据体系，深度挖掘数据价值。<br>DataOps的方法论和思想主要是被分析和数据团队使用，旨在简化数据使用、降低数据分析门槛，提高数据分析质量、缩短数据分析周期。也就是说，数据作为一种大数据时代的“新能源”，本身是需要通过平台化的能力， 实现围绕“数据集成、数据开发、数据存储、数据治理以及数据服务”等体系化的数据管理流程。更进一步，基于数据驱动的思想，进行数据分析和数据消费，通过数据赋能，做好各个业务领域的相关工作，真正解决实际生产过程中遇到的痛点问题，实现数据价值落地的场景化输出。</p><p><img loading="lazy" alt="DataOps架构（来源：Diving into DataOps: The Underbelly of Modern Data Pipelines）" src="/assets/images/1673901865690-7c0fe709-66d5-435d-8932-4b1ea88faf5b-c832fb06b8758a8c6e02ba3e5ed98db9.png" width="1146" height="762" class="img_ev3q"></p><a name="clUt1"></a><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="2-dataops能够解决哪些问题">2. DataOps能够解决哪些问题？<a class="hash-link" href="#2-dataops能够解决哪些问题" title="标题的直接链接">​</a></h2><p>下面列举一些常见的数据相关的问题，对于想要实施DataOps的公司来讲，可以判断一下是否有遇到：</p><ol><li>如何确保生产的数据质量？</li><li>如何判断生产的数据能否满足业务的需求？</li><li>如何判断某个数据型项目工程的价值并持续投入？</li><li>如何寻找大数据人才？</li><li>如何提高数据处理的性能？</li><li>大数据方案采用什么技术栈？</li><li>大数据方案的运维稳定性如何保障？</li><li>引入了多个大数据方案，如何统一进行管理？</li><li>大数据的数据权限如何管理？</li><li>数据分析结果如何指导最终的决策？</li></ol><p>上面常见的问题，可以归为三大场景：数据管理、数据运维和数据使用。通常实施数据化的公司都是在初期尝到了一些数据带来的甜头，但是在持续投入之后，却又发现这块的收益产出似乎带有很大的不确定性：数据表逐渐地被杂乱的数据堆满，数据产出链路常常延迟，而通过数据分析进行决策似乎也没像之前那么有效了。<br>简而言之，当数据量变大，数据工程变复杂之后，如果没有规范的体系和流程，整体的协作关系又容易变回小作坊形态，存在诸如数据计算口径不统一、数据重复建设以及数据质量不高等问题，需要寻求一些标准化、规范化、体系化、工程化的方式来进行解决。</p><a name="LgBMU"></a><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="3-如何进行dataops实践">3. 如何进行DataOps实践？<a class="hash-link" href="#3-如何进行dataops实践" title="标题的直接链接">​</a></h2><p>正如前文所说，DataOps本身是一套完整的数据体系建设的方法论，其目标是能够让数据持续用起来，实现“数据集成、数据开发、数据存储、数据治理以及数据服务”等数据管理能力。这也意味着需要依赖众多的数据技术或数据组件来建设和运营DataOps数据平台，进而形成高效可靠的数据资产化体系和数据服务化能力，也即针对Data的数据运维。</p><a name="Z6CI1"></a><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="数据集成">数据集成<a class="hash-link" href="#数据集成" title="标题的直接链接">​</a></h3><p>数据集成是构建企业级DataOps数据平台的第一步，依赖企业内部的跨部门协作，能够将不同来源的数据（不同的业务系统）以及不同类型的数据（结构化、半结构化、非结构化、离线以及实时数据等）进行整合，实现互联互通。从源头上避免数据的重复造轮和资源浪费问题，为构建规范化的数据体系、沉淀数据资产以及挖掘数据价值作准备。<br>数据集成一般是通过数据引入方式，将一个系统的数据按时按量集成到另一个系统中。通常采用ELT(Extract-Load-Transform，提取-加载-转换)的模式，重点在于数据汇聚，即将数据提取后直接加载到目标端存储中，这个阶段一般不做或者只做简单的数据清洗和数据处理。业界优秀的数据集成工具包括像Sqoop、DataX、Kettle、Canal以及StreamSets等。</p><a name="uY1wI"></a><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="数据开发">数据开发<a class="hash-link" href="#数据开发" title="标题的直接链接">​</a></h3><p>数据开发的目标是能够将数据集成阶段的原始数据，按照业务的需求进行加工处理、将原始的低业务价值的数据转换成高业务价值的数据资产，也就是说数据开发阶段是实现数据资产化的核心技术手段。<br>数据开发作为数据加工处理的核心阶段，通常会采用ETL(Extract-Transform-Load，提取-转换-加载)的模式并集成一系列的数据开发管控流程和工具，方便数据开发人员对ETL任务的编写、构建、发布、运维以及任务资源管控等，提升效率。通常数据开发主要分成离线数据开发和实时数据开发两大场景。<br>离线数据开发主要用于离线数据的批量定时加工处理，离线数据开发需要包含离线计算引擎、作业开发、任务调度、数据管控以及运维监控等核心能力，实际使用过程中，相关的离线ETL任务会按照预先设定的加工逻辑和ETL之间的拓扑依赖关系，进行调度执行。常见的离线处理框架包括MapReduce、Hive以及Spark等。在阿里巴巴内部也早已形成体系的MaxCompute通用大数据开发套件，快速解决用户的海量数据离线计算问题，有效降低企业成本并保障数据安全等。<br>实时数据开发主要涉及对实时流式数据的加工处理，满足像监控告警、数据大屏等对实时性要求较高的场景。在实时计算场景下，业务系统每产生一条数据，都会通过消息中间件（比如Kafka）被实时发送到流式处理平台进行加工处理，不再依赖调度引擎。常见的流式处理框架包括Storm、Spark Streaming以及Flink等。在阿里巴巴内部也基于Apache Flink构建了一站式的实时大数据分析平台，提供端到端的亚秒级实时数据加工处理分析能力。</p><a name="rt00L"></a><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="数据存储">数据存储<a class="hash-link" href="#数据存储" title="标题的直接链接">​</a></h3><p>有了数据集成和数据开发的能力，下一阶段就是考虑如何进行数据存储和数据组织，其核心是标准规范的数据仓库和数据模型建设，也就是说数据仓库是实现数据资产化的呈现载体。<br>目前用的最多的数据建模方式是维度建模，典型代表有阿里巴巴建设的“OneData”数据建模体系，主要包括数据规范定义、数据模型设计以及ETL开发规范三部分。<br>数据规范定义：数据主题域、业务过程、指标规范、名词定义以及时间周期等命名规范。<br>数据模型设计：模型层次划分(分成数据引入层ODS、数据公共层CDM以及数据应用层ADS三层，其中CDM层又包括明细数据层DWD、汇总数据层DWS和维度数据层DIM)、模型设计原则、模型命名规范、模型生命周期管理以及数据质量规范等。<br>ETL开发规范：数据处理作业的研发流程、编码规范以及发布运维原则等。</p><p><img loading="lazy" src="/assets/images/1673273821491-997ab2cf-9b88-4f34-8330-fb8045f3e640-4343b99091993727a2d44cb45173f9ee.jpeg" width="2027" height="2209" class="img_ev3q"><br>数据仓库实施工作流（来源：《大数据之路》）</p><p><img loading="lazy" src="/assets/images/1673343267505-b3a4611f-f424-4151-9f90-c075aaaa20cb-2984161d934e8c21a95c18ed9010260e.jpeg" width="2929" height="1016" class="img_ev3q"><br>数据仓库建设工程链路（离线链路+实时链路）</p><a name="eaqgP"></a><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="数据治理">数据治理<a class="hash-link" href="#数据治理" title="标题的直接链接">​</a></h3><p>数据治理主要是对数据资产，配置数据管理策略，主要包括数据标准、数据质量、数据成本以及数据安全等内容。通过多维度进行量化评估，针对数据建设提出改进与优化建议，确保数据质量、标准、安全、易用。它包含以下功能：</p><ul><li>数据标准化管理：负责数据仓库中数据的表达、格式以及定义的规范性，包括模型规范、数仓元数据规范、名词术语规范、指标规范等进行管理，针对未标准化的内容提出改进建议。</li><li>数据成本：主要从存储量和访问情况等沉淀相关治理项，比如：空表、无效表（未关联ETL任务表）、长期未访问表、长周期表、大数据量表等，通过对治理项的运作，提出优化建议，推动数据开发人员进行成本治理。</li><li>数据质量：围绕数据的完整性、准确性、一致性、有效性和及时性五个维度并对数据的重要性进行资产等级划分，对质量保障既包括事前保障，比如数据开发流程、数据标准执行等，又有事中保障，比如DQC的数据质量实时监控和告警，还有事后保障，比如数据质量故障复盘，确定质量问题根因等。</li><li>数据安全：评估数据安全风险，对数据设定安全等级，包括支持安全认证和权限管理、资源隔离、数据加密、数据脱敏等，保障数据安全可靠的被传输、存储和使用。<a name="w4y8o"></a></li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="数据服务">数据服务<a class="hash-link" href="#数据服务" title="标题的直接链接">​</a></h3><p>数据服务旨在提供统一的数据消费服务总线，能够将数据资产生成API服务，其目标是把数据服务化，让数据能够快速集成到业务场景当中，发挥数据平台的价值。它包含以下主要功能：</p><ul><li>异构跨库查询：如果数据分布在多个异构数据库时，用户无法简单的实现数据关联查询，通过数据查询服务，可以减少数据同步作业，直接实现从多个源数据库加载数据与完成查询的能力。</li><li>数据API 定义与管理：部份常用的数据点查或统计分析，可通过定义数据集与API名称，并最终暴露为一个HTTP资源路径的方式，并对数据API进行发布和访问授权，方便在各类脚本或代码中使用数据。</li><li>数据缓存：对于常用的数据查询，可定义缓存与更新策略，来减少数据查询穿透到数据库，提高性能并降低对数据库的性能负载。</li><li>服务编排：按照业务逻辑，以串行、并行和分支等结构编排多个API及函数服务为工作流。<a name="sFcux"></a></li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="数据应用">数据应用<a class="hash-link" href="#数据应用" title="标题的直接链接">​</a></h3><p>有了标准化的数据体系以后，针对数据进行分析和使用又是DataOps所关心的另一个维度的问题，这也是数据驱动的关键环节，也即以数据为中心进行决策，驱动业务行为。数据分析人员利用各种数据统计分析方法和智能算法，通过数据平台提供的数据服务API，对相关数据进行多维度、深层次的分析挖掘，支撑业务相关的数据应用场景，持续让数据用起来，真正发挥数据平台的业务价值。<br>不同的业务有各自的应用场景，所以这一部分很难面面俱到。本文仅简单介绍几种常见的数据应用场景，希望能帮助大家更好的理解，如何基于数据平台的数据资产和数据服务，进行数据分析和使用。<br><strong>数据大屏</strong>：通过对数据进行分析计算，借助BI类软件，结合业务需求，以图表等形式，把一些关键的汇总性数据展示出来，实现数据可视化，为业务决策提供准确可靠的数据支持。<br><strong>智能场景</strong>：属于AIOps范畴，基于数据平台的数据，通过AI算法，从数据中进行提炼、挖掘、洞察，为业务基于数据进行决策和运维运营时提供智能能力，获得更有前瞻性的数据支持。比较典型的智能应用场景包括像智能推荐、智能客服、智能预测以及健康管理等等。<br>当然，数据分析也并不是数据的终点，因为随着数据的沉淀，业务规模的扩大，很多数据分析的结果也可能会作为另一个更高维度模型的数据输入，被纳入数据平台的数据资产当中。因此，数据分析和开发人员需要从一个更高的维度和视角，去整合海量的数据。这也就意味着数据处理的链路并不是一成不变的，数据量会随着业务不断增长，数据模型也同样需要不断演进。</p><p><img loading="lazy" alt="数据平台架构示例" src="/assets/images/1673901865728-6fe2c7ea-463f-4d18-8a49-425f7c147e62-06dd9a29a6b26d31140c85d3e80fbbfa.png" width="1692" height="884" class="img_ev3q"></p><a name="X59GT"></a><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="4-总结">4. 总结<a class="hash-link" href="#4-总结" title="标题的直接链接">​</a></h2><p>总的来说，<strong>DataOps 作为一种数据管理方式，利用 DevOps 方法论对数据的全生命周期进行管理，通过数据平台把数据变成一种服务能力，进而提升数据的使用效率，实现数据持续用起来的目标。</strong>以数据平台为承载，以数据场景为驱动，支持更大的创新空间和更优秀的业务模式。<br>SREWorks云原生数智运维平台，沉淀了阿里大数据运维团队近十年经内部业务锤炼的SRE数智化工程实践，包含DataOps在运维领域的最佳实践，欢迎体验。我们旨在秉承“数据化、智能化”运维思想，帮助更多的从业者采用“数智”思想做好运维。</p><p><strong><em>参考材料</em></strong><br><a href="https://www.synopsys.com/blogs/software-security/agile-cicd-devops-difference/" target="_blank" rel="noopener noreferrer">https://www.synopsys.com/blogs/software-security/agile-cicd-devops-difference/</a><br><a href="https://zhuanlan.zhihu.com/p/55066486" target="_blank" rel="noopener noreferrer">https://zhuanlan.zhihu.com/p/55066486</a><br><a href="http://www.uml.org.cn/bigdata/202108115.asp" target="_blank" rel="noopener noreferrer">http://www.uml.org.cn/bigdata/202108115.asp</a><br><a href="https://en.wikipedia.org/wiki/DataOps" target="_blank" rel="noopener noreferrer">https://en.wikipedia.org/wiki/DataOps</a><br><a href="https://www.tamr.com/blog/from-devops-to-dataops-by-andy-palmer/" target="_blank" rel="noopener noreferrer">https://www.tamr.com/blog/from-devops-to-dataops-by-andy-palmer/</a></p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[SREWorks前端低代码工程设计概览]]></title>
        <id>/tpx7u2</id>
        <link href="https://sreworks.opensource.alibaba.com/column/tpx7u2"/>
        <updated>2022-08-24T07:05:17.000Z</updated>
        <summary type="html"><![CDATA[引子]]></summary>
        <content type="html"><![CDATA[<a name="OfOTG"></a><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="引子">引子<a class="hash-link" href="#引子" title="标题的直接链接">​</a></h2><p>"低代码"一词似乎是最近几年才流行起来的词汇，2015年前后AWS、Google、Oracle等厂商开始入局低代码领域时，国内氛围还没有很高。2018年5月，快速应用开发的低代码平台 OutSystems 获得 3.6 亿美金投资；同年8月，西门子宣布以 6 亿欧元收购低代码应用开发厂商 Mendix; 此后，越来越多的企业开始尝试以低代码/零代码技术重构数字化业务，低代码平台市场逐步火爆起来。<br>其实低代码开发并非新生事物，据可考的资料，低代码概念最早诞生于上世纪80年代IBM的快速应用程序开发工具(RAD)；后来微软的VB、C#可视化开发工具Visual Studio，谷歌的Android集成开发工具Android Studio等都是对其概念的工程实践。低代码本质上还是一种软件开发方式：即不写代码或少写代码的方式来完成软件开发。<br>于前端而言，低代码开发其实也并不陌生，把“低代码”描述为“页面可视化编辑”，这一概念就变得熟悉了起来，我们曾经使用过的Dreamweaver、Frontpage等其实都可以归属到低代码的范畴。随着Angular、React、Vue等前端框架的普及以及gulp，webpack等构建工具的完善，前端进入工程化协作开发时代，逐步开始承载越来越多的业务逻辑。<br>当前云原生开发火热，在容器化微服务化技术加持下，传统意义的后端开发瘦身，又催生出了前端服务化的理念。在适配行业领域，业务场景，用户群体等不同条件下，前端低代码的设计落地和工程实践相应会呈现出不同的特征与特色。</p><a name="SCzSl"></a><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="文章结构">文章结构<a class="hash-link" href="#文章结构" title="标题的直接链接">​</a></h2><ul><li>项目背景</li><li>技术架构</li><li>设计理念<ul><li>菜单树与路由</li><li>前端设计器</li><li>页面布局</li><li>动态表单</li><li>数据源</li><li>页面操作</li><li>节点参数阈</li><li>组件扩展</li></ul></li><li>愿景与规划<a name="KoMYQ"></a></li></ul><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="项目背景">项目背景<a class="hash-link" href="#项目背景" title="标题的直接链接">​</a></h2><p>SREWorks是一套面向企业级复杂业务的开源云原生运维解决方案，是大数据SRE团队多年工程实践的锤炼及沉淀。<br>解决前端开发的前端统一托管工程（sw-frontend）是运维解决方案的重要一环，提供了一套serverless体验的配置化前端低代码解决方案，该方案以运维人员为主要用户群体，集成了一套前端设计器/渲染器，提供前端页面部署，代码回滚，编译打包等功能。同时赋予运维人员根据自身业务需求，快速创建定制应用的能力，有效提升诸如支撑故障处理、监控分析、变更保障及值班/客服/大促等运维场景的运维效率。</p><a name="gzGbE"></a><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="技术架构">技术架构<a class="hash-link" href="#技术架构" title="标题的直接链接">​</a></h2><p>低代码作为一种软件开发方式，特点在于少写代码或不写代码，只通过界面的托拉拽配置即可完成满足需求场景的软件，提高了软件的开发效率。效率提升的关键在于“复用”——对于前端页面而言，就是对页面进行解构抽象，映射为json等格式的配置文件，进而对各个粒度的组件进行编排复用；通过模板引擎进行组件映射，加载，渲染，路由组装编排，数据流传递注入等完成页面挂载。<br>作为一款着力于提升运维开发效率的前端低代码产品，sw-frontend工程采用React+antd为主的技术框架，设计了一套组件映射、编排、解析、渲染的工程体系：以antd组件为自由编辑粒度，用户在前端设计器通过可视化交互或者json编辑的方式，依据运维工作的实际使用场景，对组件进行属性配置/组件嵌套拼装；同时根据运维场景目标需求对页面组件进行布局的编排、数据源的绑定以及在合适点位插入Dynamic Logic，完成页面节点的设计工作，形成节点模型nodeModel，经模板解析引擎进行解析渲染。<br>sw-frontend整体架构图如下：<br><img loading="lazy" alt="image.png" src="/assets/images/1661324725328-cb10be8c-46e6-485b-a623-2be486e92515-e3acc8d11ff43ecb3c502e4853df6521.png" width="1694" height="1380" class="img_ev3q"></p><a name="krVbk"></a><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="核心设计">核心设计<a class="hash-link" href="#核心设计" title="标题的直接链接">​</a></h2><p>低代码产品由于适配的需求场景和面向的用户群体不同，所呈现的产品形态和交互方式也各具特点：类似<strong>汽车自动驾驶</strong>，区分L1、L2、L3...，低代码产品在使用复杂度上也大体呈现几种形态：</p><ol><li>给<strong>普通用户</strong>使用的低代码产品：用户只需关心自身业务，无需代码配置，只用修改页面组件的 Data 就能快速地生成页面，通常营销活动页面都是通过此类方式快速构建；</li><li>面向<strong>中台开发</strong>的低代码产品：进行界面拖拽设计并进行json编辑配置即可；</li><li>着力于提高<strong>前端人员</strong>日常产出效率的可复用组件/插件：如json-shcema动态表等，具有一定封装粒度，旨在提升代码段复用率，提升开发效率；</li></ol><p>sw-frontend就是这样一款面向<strong>运维中台</strong>开发的低代码产品。运维是个特定的业务需求场景，搭建一个ui界面只是运维场景的需求之一；sw-fontend提供了一套满足<strong>强交互页面类型</strong>设计，serverless体验，灵活的数据流处理能力和丰富的组件扩展能力的低代码解决方案。它不单是一个低代码框架，而且还内置了或者塑造了一整套的运维工作流模式，以适配运维业务场景的使用：
<a href="/column/tpx7u2?_lake_card=%7B%22status%22%3A%22done%22%2C%22name%22%3A%22%E6%88%91%E7%9A%84%E5%BD%B1%E7%89%872%20(1).mp4%22%2C%22size%22%3A63509152%2C%22taskId%22%3A%22ubbe545d0-060c-4286-9100-371b252136e%22%2C%22taskType%22%3A%22upload%22%2C%22url%22%3Anull%2C%22cover%22%3Anull%2C%22videoId%22%3A%22inputs%2Fprod%2Fyuque%2F2022%2F703896%2Fmp4%2F1661324873023-39e92b87-c7ca-44dd-a56e-2321a06972cf.mp4%22%2C%22download%22%3Afalse%2C%22__spacing%22%3A%22both%22%2C%22id%22%3A%22X4PTE%22%2C%22margin%22%3A%7B%22top%22%3Atrue%2C%22bottom%22%3Atrue%7D%2C%22card%22%3A%22video%22%7D#X4PTE"><img loading="lazy" alt="我的影片2 (1).mp4 (60.57MB)" src="data:;base64,iVBORw0KGgoAAAANSUhEUgAABeQAAAJQCAMAAADYGpS3AAAABGdBTUEAALGPC/xhBQAAAAFzUkdCAK7OHOkAAAAbUExURePj4+/v79XV1d/f39nZ2ff399nZ2bm5ucfHx7fjGXMAAAAFdFJOUwT8+cRl0wDGrAAACO5JREFUeNrs3dFO4zAQQNHYKRP//xcvy2q1XQFNS2PsDOc89mUkg65GTesuy7Jc1hoApFLXy/JmdRYAGa1/Gl/X8gJAKmWtvyt/iSrxABkzX+PyusivTgIgo9fALzUs8gA5V/moS4RzAMgpQuQBRB4AkQdA5AEQeQBEHgCRBxB5AEQeAJEHQOQBEHkARB4AkQcQeQBEHgCRB0DkARB5AEQeQOQBEHkARB4AkQdA5AEQeQBEHkDkARB5AEQeAJEHQOQBEHkARB5A5AEQeQBEHgCRB0DkARB5AJEHQOQBEHkARB4AkQdA5AEQeQCRB0DkARB5AEQeAJEHQOQBRN4xAIg8ACIPgMgDIPIAiDwAIg8g8gCIPAAiD4DIAyDyAIg8ACIPIPIAiDwAIg+AyAMg8gCIPIDIAyDyAIg8ACIPgMgDIPIAiDyAyAMg8gCIPAAiD4DIAyDyACIv8gAiD4DIAyDyAIg8ACIPgMgDiDwAIg+AyAMg8gCIPAAiD4DIA4g8ACIPgMgDIPIAiDwAIg8g8gCIPAAiD4DIAyDyAIg8ACIPIPIAiDwAIg+AyAMg8gCIPAAiDyDyAIg8ACIPgMgDIPIAiDyAyAMg8gCIPAAiD4DIAyDyAIg8gMgDIPIAiDwAIg+AyAMg8gAi7xgARB4AkQdA5AEQeQBEHgCRBxB5AEQeAJEHQOQBEHkARB4AkQcQeQBEHgCRB0DkARB5AEQeQOQBEHkARB4AkQdA5AEQeQBEHkDkARB5AEQeAJEHQOQBEHkAkRd5AJEHQOQBEHkARB4AkQdA5AFEHgCRB0DkARB5AEQeAJEHQOQBRB4AkQdA5AEQeQBEHgCRBxB5AEQeAJEHQOQBEHkARB4AkQcQeQBEHgCRB0DkARB5AEQeAJEHEHkARB4AkQdA5AEQeQBEHkDkARB5AEQeAJEHQOQBEHkARB5A5AEQeQBEHgCRB0DkARB5AJF3DAAiD4DIAyDyAIg8ACIPgMgDiDwAIg+AyAMg8gCIPAAiD4DIA4g8ACIPgMjDEUpt27drtTh5RB76q9sg1dkj8tBb24ZpTh+Rh6R7vF0ekYfuyjaU9+UReUi7yFvlEXnoq42NvHflEXnoaRvMXwCRB5EHkYdnIt/+PQIt7dgCf8MIEHm4WeDrj7mUPpHvOAJEHm4WeP/FmUeAyIPIg8gj8iIPIo/IizwiDyIv8og8iDyIPIg8iDyIPIg8iDyIPCIv8iDyiLzII/IwceTdXQMiT+LIu4USRJ7Eke942bv75BF5EHkQeRgf+WhRRB6Rh5yRf3szPbqOAJGHUZF/9wxV5BF5yBb5basij8hD3sg/sMyLPCIPp4v8/cu8yCPycMLI//8dVpFH5CFZ5LdaOowAkYc5In/XpylFHpGHs0b+jgewIo/Iw2kjv7/MizwiDyeO/N4yL/KIPJw58jvLvMgj8nDuyN9c5kUekYfhka/xV/1C5G8t84+OAJGHoyN//Y8bX4n851+NenQEiDwcHfn9F3cj/9k9B37IG5GHDJH/ZJkXeUQeckR+ayKPyEPeyH/0AFbkEXlIE/n378yLPCIPeSL/bpcXeUQeRB5EHk4Q+Xh2BIg8zBr5D+43EHlEHpJEvh4wAkQepox882UoRB7SRj6OGQEiD0dH/vkLypoLyhB5mDXyrhoGkSdz5P1oCIg8Iu/n/xB5+GGR90PeiDzkjXwcPAJEHqaJ/M4aL/KIPJw38i2OHwEiD3NEvvUYASIPU0S+dBkBIg8TRL52GgEiD+MjX3qNAJGH0ZGPfiNA5GFs5FvpOAJEHkZFvj24xos8Ig8nivxLtCidR4DIw6jITzkCRB5EHkSenxr5q0epv9q5YxQGQiCAojqKeP8Tr0mVagMBcTO8V24j7MBnsLDOPZHfeASIPNwW+POeve6J/MYjQOThtsDfPz75CBB5EHkQeURe5EHkEXmRR+RB5EUekQeRB5EHkQeRB5EHkQeRB5FH5EUeRB6RF3lEHh4ceW/XgMiTOPJeoQSRJ3HkTzEBRB5EHkQefjHPNn6aACIPG8XZyIcJIPKwUT0b+WoCiDykXeUt8og8bDbdyIPIY5e3x4PI85dqHNjmZ7iPR+QBEHkARB4AkQdA5AFEHgCRB0DkARB5AEQeAJEHQOQBRB4AkQdA5AEQeQBEHgCRBxB5AEQeAJEHQOQBEHkARB4AkQcQeQBEHgCRB0DkARB5AEQeAJEHEHkARB4AkQdA5AEQeQBEHkDkARB5AEQeAJEHQOQBEHkARB5A5AEQeQBEHgCRB0DkARB5AJEHQOQBEHkARB4AkQdA5AEQeQCRB0DkARB5AEQeAJEHQOQBEHkAkQdA5AEQeQBEHgCRB0DkAUQeAJEHQOQBEHkARB4AkQdA5AFEHgCRB0DkARB5AEQeAJEHEHmRBxB5AEQeAJEHQOQBEHkARB5A5AEQeQBEHgCRB0DkARB5AEQeQOQBEHkARB4AkQdA5AEQeQCRB0DkARB5AEQeAJEHQOQBEHkAkQdA5AEQeQBEHgCRB0DkARB5AJEHQOQBEHkARB4AkQdA5AFEHgCRB0DkARB5AEQeAJEHQOQBRB4AkQdA5AEQeQBEHgCRBxB5AEQeAJEHQOQBEHkARB4AkQcQeQBEHgCRB0DkARB5AEQeAJEHEHkARB4AkQdA5AEQeQBEHkDkARB5AEQeAJEHQOQBEHkARB5A5AEQeQBEHgCRB0DkARB5AJEXeQCRB0DkARB5AEQeAJEHQOQBRB4AkQdA5AEQeQBEHgCRB0DkAUQeAJEHQOQBEHkARB4AkQcQeQBEHgCRB0DkARB5AEQeAJEHEHkARB4AkQdA5AEQeQBEHgCRBxB5AEQeAJEHQOQBEHkARB5A5AEQeQBEHgCRB0DkARB5AEQeQOQBEHkARB4AkQdA5AEQeQCRB0DkARB5AEQeAJEHQOQBEHkAkQdA5AEQeQBEHgCRB0DkARB5AJEHQOQBEHkARB4AkQfgPvIxqv8AkFEdUdpofgRARivwpY+wygNkXORj9LJW+WgyD5At8S3WIl9elQcgoXfjS+kr9wCkEq2vwF/AS3FPDp78OwAAAABJRU5ErkJggg==" width="1508" height="592" class="img_ev3q"></a><a name="jgfny"></a></p><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="菜单树与路由">菜单树与路由<a class="hash-link" href="#菜单树与路由" title="标题的直接链接">​</a></h3><p>sw-frontend以用户创建的各个应用为一级路由构建起整个前端工程的菜单体系，所有的页面都是依托“应用”为节点进行挂载的。下图为应用<strong>运维桌面</strong>，用户可以点击应用快捷方式进入运维应用。<br><img loading="lazy" alt="image.png" src="/assets/images/1661324734304-7e8acc35-2fbb-495c-b9ba-869f8f094ecf-f2e8b80b05a47c998c7cffc60365b5db.png" width="2880" height="1584" class="img_ev3q"><br><strong>运维桌面</strong>同时也是我们应用维度的其中一员，即在sw-frontend的总体设计概念上：一切皆是应用。<br><img loading="lazy" alt="image.png" src="/assets/images/1661324729028-0cb3f742-e1ee-4b26-980b-52672c5f5984-208df93a3c7e3a55e3256352d2061f9a.png" width="2880" height="1586" class="img_ev3q"></p><a name="msiIU"></a><h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="菜单节点树">菜单节点树<a class="hash-link" href="#菜单节点树" title="标题的直接链接">​</a></h4><p>我们将运维应用前端页面中的菜单以树形节点（nodeTree）的形式组织起来，根结点映射为应用ID。从根节点创建的子节点，则作为一级菜单，以此类推孙子节点为二级菜单。如下图数据运维平台（appID：dataops）应用所示，一级菜单为“主页、资产目录、数据资产、数据管理、数据服务、数据质量”。该页面是dataops应用前端的渲染态。<br><img loading="lazy" alt="image.png" src="/assets/images/1661324723135-56125203-0a46-4ce4-adb6-2e0e337c4a91-bc464511aa52bb14002a36319c58872a.png" width="2876" height="1418" class="img_ev3q"><br>进入到dataops应用的开发态，在前端开发编辑器中，我们可以从左侧菜单节点树看到与上面菜单一一对应的内容，每个节点上挂载了该页面的具体配置，每个页面配置包含一个主页面和多个页面区块配置，维护管理在页面设计器中。<img loading="lazy" alt="image.png" src="/assets/images/1661324728075-f6650b5e-6f3b-4ecd-a312-dff83e0e7db9-d58791b6d526fd24879aed75ecbc21c1.png" width="2876" height="1286" class="img_ev3q"></p><a name="iOnwc"></a><h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="动态路由生成">动态路由生成<a class="hash-link" href="#动态路由生成" title="标题的直接链接">​</a></h4><p>每个应用的页面菜单都抽象为一个页面节点树nodeTree，并在Node节点上可以对节点类型和菜单页布局以及权限等信息进行配置(菜单/Link作为嵌套路由使用)。我们将挂在在该节点的主页面和页面区块的相关配置：属性、数据源、编排等进行配置，我们称之为节点配置（nodeConfig）。<br><img loading="lazy" alt="节点树示意图" src="/assets/images/1661324728314-e4ec84e6-8ea4-46a7-a75d-3df79d9fe12f-aa0158881c5c20c1e22357264a7151f9.png" width="2574" height="1462" class="img_ev3q"><br>在一级路由页运行渲染时，根据应用id(appId)拉取对应nodeConfig，如下以"运营中心"为例，对应的应用配置如下：其中children所代表的为二级路由；config代表的是该级节点的属性配置；nodeTypePath字段作为描述节点树的上下级关联关系key；每一级子路由进行渲染挂载都会依据nodeTypePath先去索引其下一级子路由nodeModel，用于装载子级的动态路由。<br><img loading="lazy" alt="image.png" src="/assets/images/1661324726993-c73fa888-2255-4d24-abe5-aaa5ab4c3f99-1fffa16011ec934a121e32667c71a0de.png" width="888" height="548" class="img_ev3q"><br>nodeTypePath也是作为子节点获取对应节点页面配置的索引key，用以拼接组装该节点的动态子路由。<br><img loading="lazy" alt="image.png" src="/assets/images/1661324730454-ea71c956-78b9-44c1-b3ce-230d9aeb62a3-acd4ad66e6f45aaf54679d986d799e6b.png" width="867" height="500" class="img_ev3q"></p><a name="l1CQj"></a><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="前端设计器">前端设计器<a class="hash-link" href="#前端设计器" title="标题的直接链接">​</a></h3><p><strong>swadmin</strong>作为内置应用的一员，同时也是其他应用的母应用，一生万物，所有应用的都是通过前端设计器设计配置而来；在此可以对组件/页面进行业务字段、ui和数据源的配置，对当前应用的节点树进行编辑，以及对每级节点对应页面的组件进行属性配置、数据源绑定和布局编排工作。<br>swadmin提供了两种交互编辑方式：</p><a name="p6Np5"></a><h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="可视化交互编辑">可视化交互编辑<a class="hash-link" href="#可视化交互编辑" title="标题的直接链接">​</a></h4><p>如下图就是在对staticPage这一应用下的一级菜单"pageScreen"页面进行开发编辑，下方弹窗区为对页面内大屏组件的属性进行可视化配置。<br><img loading="lazy" alt="可视化编辑模式" src="/assets/images/1661324731556-bf452a18-db89-4508-bf09-4916b691d8b7-0c3660b3943a1fc0134b837dee7deb49.png" width="2878" height="1490" class="img_ev3q"></p><a name="WVXni"></a><h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="源码编辑json编辑">源码编辑（JSON编辑）<a class="hash-link" href="#源码编辑json编辑" title="标题的直接链接">​</a></h4><p>除了可视化设计界面外，同时也提供了源码编辑，直接修改映射配置，以提供更大的灵活性；且可以在源码编辑和可视化编辑之间进行灵活切换，并保持同步的编辑态。<br><img loading="lazy" alt="源码编辑模式" src="/assets/images/1661324732806-5efaa86d-9df9-4732-9793-c4c94282cfef-b7503c6a17dba3813f7a60e652b63970.png" width="2880" height="1486" class="img_ev3q"></p><a name="j3Zbc"></a><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="页面布局">页面布局<a class="hash-link" href="#页面布局" title="标题的直接链接">​</a></h3><p>sw-frontend内置两种页面布局类型：自定义布局和流式布局(自定义布局当前只在内置应用使用，暂未对外部应用开源使用)。对于流式布局我们将页面抽象成若干行容器，在新增行容器时可以自定义分割成若干区块并并确定分割占比，每个区块对应一个组件容器位。<br><img loading="lazy" alt="流式布局" src="/assets/images/1661324731544-a1e0d75e-c4ee-4b50-bd82-aac76f0f3372-7fbda1387760587d77cd1012f2cbb1c9.png" width="945" height="713" class="img_ev3q"><br>对于自定义布局，可以根据业务需要对添加进入的区块组件任意拖拉改变宽高以及布局位置：<br><img loading="lazy" alt="自定义布局" src="/assets/images/1661324732654-a716f907-8eed-4610-a0cc-d1d2778a642c-a49dab3063ab8a744d1b0c63bdadeb33.png" width="945" height="713" class="img_ev3q"></p><a name="y3Wf3"></a><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="组件体系">组件体系<a class="hash-link" href="#组件体系" title="标题的直接链接">​</a></h3><p>sw-frontend采取声明式组件注册机制，每个内置组件由meta元数据文件和主文件两份文件构成，其中meta以json格式用来描述该组件的一些可配置属性及组件的属性默认值和组件名称、组件ID等信息用于组件的注册和loader加载；主文件则用来承接用户对组件的配置信息和数据源数据及一些外部嵌入的逻辑代码。</p><table><thead><tr><th><img loading="lazy" alt="image.png" src="/assets/images/1661324733615-ad09c057-9a5c-459c-bc38-59ec80d72a6c-742949aa2c5cb114fa4af469bd41bcf4.png" width="452" height="1318" class="img_ev3q"></th><th><img loading="lazy" alt="组件结构图" src="/assets/images/1661324733609-8f8cc164-5fa5-4d73-9e3b-0730cdadc243-0d8b67958dfddf86be8640960992c446.png" width="1200" height="1350" class="img_ev3q"></th></tr></thead></table><p>同时页面提供自定义组件入口，供用户自行设计一些简单的组件以JSXRender方式进行渲染，且用户可以对自定义组件进行添加删除和编辑管理。<br><img loading="lazy" alt="自定义组件管理" src="/assets/images/1661324734470-b1f3fe8e-4398-42b7-a205-a8f3c8d702c2-d72acfbf2d3b4357e2cc9100cc96c1da.png" width="2876" height="1056" class="img_ev3q"></p><a name="n6dNj"></a><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="动态表单">动态表单<a class="hash-link" href="#动态表单" title="标题的直接链接">​</a></h3><a name="zcLwc"></a><h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="表单工厂">表单工厂<a class="hash-link" href="#表单工厂" title="标题的直接链接">​</a></h4><p>页面交互还有重要的一环：<strong>表单数据的交互</strong>。sw-frontend提供了近三十种输入形式的表单项以供表单设计选择使用，对于Form表单提供了界面化的属性配置如：表单项类型、是否展示、表单项数据源、表单项条件渲染、表单项label、表单项key，表单拖拽排序，动态添加表单项等。<br><img loading="lazy" alt="image.png" src="/assets/images/1661324735915-3b40e33f-ea18-44d7-a31c-2f21288f3c0c-bdaf25714f36ea4b5eb491a7aa616324.png" width="2880" height="1362" class="img_ev3q"><br><img loading="lazy" alt="image.png" src="/assets/images/1661324735984-f1260472-3c47-4108-b0b5-99e0c12db8cf-0064808d4c5308e6e3487425500f0651.png" width="2880" height="900" class="img_ev3q"></p><p>对于表单数据的编辑回填,以及表单和页面的数据流以及action交互，也做了模型化的抽象处理，这个在后面页面操作章节做详细介绍。</p><a name="a3N4N"></a><h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="过滤器表单action">过滤器/表单Action<a class="hash-link" href="#过滤器表单action" title="标题的直接链接">​</a></h4><p>对于页面的表单Action，如新增、编辑等，sw-frontend抽象为单独的操作区块，每个操作区块创建时会生成unikey，在页面组件工具栏区添加好操作button后，可以通过页面交互或源码编辑的形式建立绑定关系。<br><img loading="lazy" alt="区块绑定示意图" src="/assets/images/1661324737815-2efe31fa-cb2d-407c-a110-b5338f081c28-0c290d5d8b448f09d431cecb629a1672.png" width="2880" height="1500" class="img_ev3q"><br>源码视角下，在table组件的toolbar字段下，“新建应用”button以blockId的形式跟新建应用的表单操作区块建立了绑定关系；当模板引擎解析到toolbar工具栏，会用该blockId获取到该操作区块的配置，然后根配置以表单工厂函数加载对应表单项并对其表单项值初始化。<br><img loading="lazy" alt="源码视角区块绑定形式" src="/assets/images/1661324738735-f1f3355d-e56f-4ae4-9e07-3e3167643acc-a6837f5841cdebea96c608fc97712d3d.png" width="2880" height="1496" class="img_ev3q"></p><a name="ypbiP"></a><h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="过滤器">过滤器<a class="hash-link" href="#过滤器" title="标题的直接链接">​</a></h4><p>过滤器是对传统页面开发条件中过滤表单的一种抽象，在设计器中对过滤器的定义和action表单操作大体一致，只是过滤器没有表单提交地址，关联组件如table的过滤刷新，是经由过滤器将表单项的字段值投递到参数阈，table的数据源获取执行器进而通过侦听对比参数阈的关联字段值的变化重新拉取数据，来<strong>间接</strong>完成表格数据的过滤查询操作；而action操作则是将表单提交到后端地址，确认成功提交后通过callback来完成参数阈投递更新，<strong>间接</strong>完成组件的数据刷新操作。</p><table><thead><tr><th>过滤器<br><img loading="lazy" alt="image.png" src="/assets/images/1661324739070-bdc86fb8-8dce-4aed-83d7-6b322b45cfb8-572363e2e38295c8317b48e89e0523ad.png" width="2880" height="1486" class="img_ev3q"></th><th>action操作<br><img loading="lazy" alt="image.png" src="/assets/images/1661324740048-e5a7b02a-898a-44c7-81e1-a0acb8ec0183-52cf8fd3e1904cbc98de50f22ec63f8d.png" width="2880" height="1482" class="img_ev3q"></th></tr></thead></table><a name="YpNE7"></a><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="数据源">数据源<a class="hash-link" href="#数据源" title="标题的直接链接">​</a></h3><p>sw-frontend提供了灵活的数据流处理机制，降低对接口的数据格式及参数的固定要求，使应用富客户端化，这也是serverless体验的关键一环：在此用户可以灵活定义组件/页面节点数据源类型，提供类似GraphQL的模式，在设计器中对返回数据进行灵活处理。<br><img loading="lazy" alt="数据源定义示意图" src="/assets/images/1661324740916-ec0106aa-267b-458e-964e-bb77b4514ed4-559aee2059b2d7d8fde15f750539f275.png" width="2880" height="1486" class="img_ev3q"><br>对于数据源为api格式的地址中使用$(变量名)，会统一从参数阈中渲染替换，然后获取组件数据源的数据；同时提供请求前置函数和请求后置函数的执行钩子，在这里可以进行数据的拆解或组装以及写入一些业务逻辑代码。<br><img loading="lazy" alt="钩子函数编辑区" src="/assets/images/1661324742374-bb0f17cc-d648-4f6f-9d5c-3ab218004ac0-03896d107adf6c4a6fd159090273d788.png" width="2880" height="1486" class="img_ev3q"></p><a name="GyLcb"></a><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="页面操作action">页面操作（Action）<a class="hash-link" href="#页面操作action" title="标题的直接链接">​</a></h3><p>页面操作是低代码工程设计里面的重要一环，承载着很大一部分运维需求场景，sw-frontend将页面操作抽象为四个大的类别：工程内置操作类，过滤器类，表单提交类，超链跳转类。<br><img loading="lazy" src="/assets/images/1652374762157-3109b42d-f688-46ca-92c1-3d3ce449908d-6955b86a1e3f27397983d7fd01be82f3.jpeg" width="1400" height="1016" class="img_ev3q"></p><ul><li>工程内置操作类</li></ul><p>sw-frontend在组件的工具栏内置了若干通用的按钮类的操作，根据操作类型map，识别相应操作进行渲染。典型的如“组件刷新”操作，用户在界面添加该按钮，配置唯一识别字段"<strong>refresh</strong>"，即可完成组件刷新操作的配置，该刷新Button通过触发参数阈改变事件，间接完成组件的数据刷新操作。</p><ul><li>超链跳转类</li></ul><p>超链跳转类别的操作，常用于表格等组件的行内操作，一般以JSXRender的形式进行配置，渲染为			Button/Link。进行路由跳转或者超链跳转时，表格行内数据可以作为传入参数使用。</p><ul><li>过滤器类</li></ul><p>过滤器本质而言是对传统开发方式下页面查询的一种抽象：组件本身定义有数据源，过滤器的职能是触发组件重新获取数据。在sw-frontend中，过滤器的表现形式可以是一组tab、一组表单项。以表单类过滤器为例：用户在填充各过滤条件之后，“提交”操作本质并没有直接的提交地址，而是进行表单参数的投递--改变节点参数阈，组件通过监听参数阈关联字段的改变，重新拉取数据，完成传统页面的查询操作。</p><ul><li>表单提交类</li></ul><p>表单操作承载了大部分的页面操作，sw-frontend将常规的“增”、"删"、"改"都抽象为表单提交类的事件，对这类Action操作，在完成和服务端交互后，以callback的形式，进行节点参数阈字段的投递，以触发数据渲染类组件的刷新从而完成“增”、"删"、"改"类的操作，如下两图分别为Action操作定义和运行时渲染界面：<br><img loading="lazy" alt="Action定义" src="/assets/images/1661324741913-1bda66bb-c6cf-40fd-ab2a-021451106a18-e5d4ff952456968a46281dbae4fcb71f.png" width="2854" height="1520" class="img_ev3q"><br><img loading="lazy" alt="Action渲染态" src="/assets/images/1661324743072-3095e15b-c67a-4e60-9319-5ea2ed73fdd1-81ddcfccbb291eddb83e468eab2cc666.png" width="2152" height="1530" class="img_ev3q"><br>其中在进行数据编辑时的表单数据回填，大多数场景为列表类数据的编辑：<strong>定义在行内的“编辑”操作会绑定一个表单Action区块；在点击事件发生时，会将该行内数据对象rowData与当前节点参数阈合并，作为actionParams传入该Action表单区块，表单区块通过读取actionParams的对应字段value作为各表单项的initValue，完成数据回填。</strong></p><a name="OQs9a"></a><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="节点参数域">节点参数域<a class="hash-link" href="#节点参数域" title="标题的直接链接">​</a></h3><p>节点参数阈是以Redux状态管理机制为依托，建立路由节点页面共享参数对象nodeParams，节点页面各组件通过对nodeParams的修改和对应字段侦听来间接完成组件间的信息传递和事件交互。<br>sw-frontend在节点页创建之初，会初始化节点参数域：nodeParams；在节点页面的生命周期内，也会将url中变量参数，一些页面交互产生的runtime参数以及外部函数投递来的参数整合到节点参数域中来。<br><img loading="lazy" alt="节点参数阈查看示意图" src="/assets/images/1661324744146-a0e83732-95b3-4ee4-aae7-8190eac242f1-aa58ab57319f5cb586cac87cb05136a9.png" width="2872" height="1576" class="img_ev3q"><br>随之组件在经过统一数据源处理器获取数据流渲染之后，会对节点参数阈的target字段值通过监听对比，以触发数据reload刷新机制，重新获取数据源数据；同时页面的一些action表单操作，也是通过参数阈投递更新目标字段值进行进行间接触发相应组件的reload刷新渲染。<br><img loading="lazy" alt="参数阈交互示意图" src="/assets/images/1661324745365-8ae686d0-3199-47df-97e8-91b317d9fc9e-49298bb3260c191a629f41df5024f11a.png" width="2818" height="1548" class="img_ev3q"></p><a name="llnrG"></a><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="组件扩展">组件扩展<a class="hash-link" href="#组件扩展" title="标题的直接链接">​</a></h3><p>sw-frontend提供了声明式内置组件的注册机制，同时开辟了用户自定义组件的入口，用户可以将一些常用的自定义组件嵌入到我们的组件列表，以供前端设计器统一调拨；当前自定义组件以JSXRender的方式进行执行，可以直接书写JSX代码，同时能够识别antd组件，赋予用户更加灵活的页面渲染能力。<br><img loading="lazy" alt="自定义组件编辑区" src="/assets/images/1661324745933-67d89b8a-5731-4b57-a68d-e42313540347-f7c942116334bc6cdf07816e96dec829.png" width="2880" height="1584" class="img_ev3q"></p><a name="mOfBC"></a><h2 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="愿景与规划">愿景与规划<a class="hash-link" href="#愿景与规划" title="标题的直接链接">​</a></h2><p>现sw-frontend已内置运维场景常用的基础组件，图表组件，landing组件，布局组件等五十余个组件，除此之外还开放了用户自定义简单JSX组件的入口，让用户对自定义组件进行编辑管理，以拓展组件扩展和插拔使用的空间。同时动态加载远程组件，建立运维组件生态市场也纳入到了后面的版本规划中；以期能够共建打造出一个丰富共享的运维组件生态来，这也是我们将其开源的一个初衷愿景。<br><img loading="lazy" alt="image.png" src="/assets/images/1661324745990-c19dcf19-5b53-450f-bf40-199e7c778e07-5b6a2b641429ab07895055794fccaec9.png" width="1726" height="1578" class="img_ev3q"></p><p>版本动态： 我们会根据工作项目节奏，持续对功能进行完善优化和升级。近期在5月上旬发布了一个小版本，该版本加入了页面模板保存和从模板快速创建的功能，以进一步聚焦"复用"，提升开发效率。</p><p>同时也欢迎大家多提issue,协力将SREWorks打造得更好: <br><a href="https://github.com/alibaba/SREWorks/tree/main/paas/sw-frontend" target="_blank" rel="noopener noreferrer">https://github.com/alibaba/SREWorks/tree/main/paas/sw-frontend</a></p>]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[基于Elasticsearch生长的SREWorks数据化运维体系]]></title>
        <id>/xsn02u</id>
        <link href="https://sreworks.opensource.alibaba.com/column/xsn02u"/>
        <updated>2022-08-22T23:07:28.000Z</updated>
        <summary type="html"><![CDATA[开源Elasticsearch是一个基于Lucene的实时分布式的搜索与分析引擎，是遵从Apache开源条款的一款开源产品，是当前主流的企业级搜索引擎。作为一款基于RESTful API的分布式服务，Elasticsearch可以快速地、近乎于准实时地存储、查询和分析超大数据集，通常被用来作为构建复杂查询特性和需求强大应用的基础引擎。]]></summary>
        <content type="html"><![CDATA[<p>开源Elasticsearch是一个基于Lucene的实时分布式的搜索与分析引擎，是遵从Apache开源条款的一款开源产品，是当前主流的企业级搜索引擎。作为一款基于RESTful API的分布式服务，Elasticsearch可以快速地、近乎于准实时地存储、查询和分析超大数据集，通常被用来作为构建复杂查询特性和需求强大应用的基础引擎。</p><p>2017年，阿里云携手Elastic合作推出了阿里云Elasticsearch服务，在100%兼容开源功能的同时，支持开箱即用、按需付费。通过 Elastic 创新的检索技术与阿里云自研的云原生高性能内核、达摩院 NLP 分词与向量检索等能力，帮助企业客户提升业务成效，并节约费用支出。在切实提高企业应用程序性能的同时，提升业务的敏捷性和智能化，缩短解决问题所需时间，使客户可以专注于自身业务创新。</p><p>基于"源于开源，又不止于开源"的产品理念，阿里云Elasticsearch持续在包含智能运维在内的可观测场景进行云原生引擎能力升级，作为业内首个Serverless Elasticsearch云服务，云上日志增强引擎可提供基于读写分离架构的Indexing Service写入加速服务、Openstore海量存储服务，从而实现Elasticsearch写入及存储Serverless，为用户带来更低成本、更高性能、更简单易用的全观测场景能力。</p><p>ELK作为业界处理与分析日志首选的解决方案，由搜索引擎Elasticsearch、采集与解析工具 Logstash、轻量级采集组件Beats、可视化分析工具Kibana等工具组成，形成了一整套生态矩阵。目前阿里云已经成功将全套ELK搬到了云上为用户提供服务，可以被广泛应用于实时日志处理、全文搜索和数据分析等领域。SREWorks正是基于以Elasticsearch为主的生态矩阵，构建了一套应用全观测数据化运维最佳实践。</p><a name="q0lag"></a><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="1-数据化运维体系是什么">1. 数据化运维体系是什么<a class="hash-link" href="#1-数据化运维体系是什么" title="标题的直接链接">​</a></h3><p>数据化运维体系，是一套把所有系统的运维数据采集起来、真正打通，深度挖掘这些数据的价值，通过数据驱动运维并为运维提供数据决策，同时能将生产系统进行“运维量化管理”的数据化运维业务模型。基于该模型建立标准化运维数仓，建设数据运维平台，在平台中规范运维数据的采集，存储，计算以及分析，并提供一系列数据化服务，供上层运维场景使用。</p><a name="CKt9q"></a><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="2-sreworks数据化运维平台">2. SREWorks数据化运维平台<a class="hash-link" href="#2-sreworks数据化运维平台" title="标题的直接链接">​</a></h3><p>SREWorks数据化运维平台包含一个核心和多个数据服务，一个核心即运维数据仓库，提供标准运维数据模型；多个数据服务即围绕运维数据的采集、存储、计算以及分析的数据化链路，提供的规范化数据服务，支撑应用的运维量化。<br> <br><strong>运维数仓</strong><br>基于开源Elasticsearch建设标准化运维数仓，抓住数据化运维本质，抽象三大数据主题和九个数据域，内置涵盖云原生数据运维场景的数据实体和数据模型。数仓具备灵活的用户自定义实体/模型能力，充分满足用户的个性化需求。<br><img loading="lazy" alt="image.png" src="/assets/images/1661209668325-f0e81ee3-8ce1-4557-b65d-f7ebbece2d72-d6782bde1ed4070ef540320c82dce09e.png" width="749" height="370" class="img_ev3q"><br>数仓数据后端采用Elasticsearch存储，其分布式索引架构、多副本、索引生命周期管理以及数据冷热存储分离等特性，很好的满足了数仓的稳定性和动态性基本特性。同时可以对接多种数据处理工具(Logstash、Spark、Flink、APM Server)，最终数据落地Elasticsearch，支撑起整个运维数仓的存储和检索能力。<br><img loading="lazy" alt="image.png" src="/assets/images/1661209668998-14cbe1dc-d5df-4332-8790-f41fcb5f5503-dc93001b39da0e0e778fbbe4fda4e209.png" width="2539" height="613" class="img_ev3q"><br><strong>数据采集服务</strong><br>集成metricbeat、filebeat、skywalking等数据采集agent，以全托管方式，进行可观测数据采集，包括Node/Pod/Container资源/负载指标、状态指标、运维事件、Prometheus外围指标、服务(容器)日志采集解析、服务追踪调用链采集分析等。metricbeat支持基于标签的服务自动发现能力，默认监听10800端口，主动采集满足标签条件服务上报的业务指标数据。<br>作业平台采集场景服务，属于自研数据采集服务，支持多种数据采集脚本，关联数仓模型，通过SREWorks运维数仓托管业务的运维数据。<br><img loading="lazy" alt="image.png" src="/assets/images/1661209668921-d083c10d-2026-4ecd-b747-3015fa5daeab-01fc3990d00e5ee67dbb6f5cc32969f3.png" width="1427" height="1141" class="img_ev3q"></p><p><strong>数据计算/分析服务</strong><br>开源Apache Flink是一个⼀站式实时大数据分析平台，通过标准SQL降低业务开发门槛，提供端到端实时数据分析能力。同时内置常规数据处理UDF(阈值检测、数据聚合、数据降采样)，支撑时序数据的流式加工处理。<br>作业平台数据化场景服务，覆盖巡检、分析、诊断等多个数据化场景，可自定义数据处理逻辑，满足用户个性化数据处理要求。</p><p><strong>指标服务</strong><br>提供指标定义和指标实例的配置与管理，已经内置基础资源和基础性能指标，用户可以按需新增指标。新增指标可以关联到采集场景服务，支持指标数据推送kafka队列，用于进行下游数据计算消费。<br><img loading="lazy" alt="image.png" src="/assets/images/1661209669016-d08b6257-79d9-4087-90d2-44edcdf39d76-4e14a3c2a7aa7961aec5c7e12e5547af.png" width="1793" height="930" class="img_ev3q"><br>**  <strong><br></strong>数据集服务**<br>数据集服务提供快速将运维数仓模型存储数据表或者用户自定义数据源表生成API的能力，用户无需具备编码能力，即可快速配置数据接口，实现数据的管理和消费。目前优先支持elasticsearch和mysql数据源。<br><img loading="lazy" alt="image.png" src="/assets/images/1661209669026-d4539c5c-cbfe-4cba-8d65-b8fcb3bb1073-84a91f07b2305613819720ae997aaf4d.png" width="2530" height="828" class="img_ev3q"></p><a name="O1CXu"></a><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="3-基于sreworks数据化运维实践">3. 基于SREWorks数据化运维实践<a class="hash-link" href="#3-基于sreworks数据化运维实践" title="标题的直接链接">​</a></h3><a name="iAuAX"></a><h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="31-稳定性建设">3.1 稳定性建设<a class="hash-link" href="#31-稳定性建设" title="标题的直接链接">​</a></h4><p><strong>服务链路全观测建设</strong><br>由于IT系统日益增加的复杂度、大量云原生技术的采用，使得服务快速排障变得越来越难。而指标、日志和追踪三大可观测性支柱，可以实现服务的白盒监控能力。<br><img loading="lazy" alt="image.png" src="/assets/images/1661209670366-4f39fafb-1471-4a11-b4ae-5ff679d08c87-85a0f94410cffa28d89162fc3e0e7ee3.png" width="676" height="400" class="img_ev3q"><br>SREWorks数据平台集成metricbeat、filebeat、skywalking等数据采集agent和自研数据采集场景作业，提供全托管一站式可观测数据采集能力，可以直接获取运行系统的指标、日志和调用链，协助问题的排查和诊断，缩短故障恢复时长(TTR)。<br><img loading="lazy" alt="image.png" src="/assets/images/1661209670680-1f16ef9a-1db5-42ef-ae0e-97a6ee1a2fcd-67bf4a5cb93edeebf1e4eee34ea9b0c5.png" width="1783" height="420" class="img_ev3q"><br><strong>健康管理服务建设</strong><br>为了帮助用户更好的感知系统运行状态，实现系统的监控管理，结合阿里Emon团队的智能检测服务和自研作业场景服务，构筑健康管理服务。包括事件采集管理、风险巡检、指标告警检测、异常诊断场景作业，帮助用户识别风险、分析告警、进行异常诊断和自愈以及故障管理。<br>建设规范化健康管理平台，能够降低或者消除系统隐患，尽最大可能将潜在故障扼杀在萌芽状态。一旦故障发生及时通知关联人员，进一步提升应对效率，确保行动的有效性。<br><img loading="lazy" alt="image.png" src="/assets/images/1661209671031-1823814c-5e51-46f0-a37d-be2844f6257b-d137a00245f55b7e0f4ea896f47cfe42.png" width="1790" height="1182" class="img_ev3q"></p><a name="PM3C0"></a><h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="32-成本建设">3.2 成本建设<a class="hash-link" href="#32-成本建设" title="标题的直接链接">​</a></h4><p>当前云原生服务成为云计算主流的服务形态，但由于云原生化的应用程序及其资源需求常常是动态变化，这也导致云成本的计算复杂性。为此，SREWorks内置一套完整的成本管理解决方案，包含资源消耗计量计费的可视化、资源使用明细分析，用于辅助用户优化和治理云资源成本。<br>SREWorks系统设置下的成本定价模型，重点从资源层面（CPU、内存、存储）进行成本核算。平台会自动按照应用粒度，每天进行应用资源用量和成本计费汇总，汇总数据自动同步至数据仓库<strong>应用成本模型(APP_COST)</strong>存储。<br><img loading="lazy" alt="image.png" src="/assets/images/1661209671053-fa10ef61-3bfa-44d1-9302-efac1ee9718a-4b9fa053e663a7590362ad2a1e5a1463.png" width="1798" height="568" class="img_ev3q"></p><a name="fLyNY"></a><h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="33-效率建设">3.3 效率建设<a class="hash-link" href="#33-效率建设" title="标题的直接链接">​</a></h4><p>运维效率即运维活动的效率，代表了运维的平台化能力，包括自动化运维操作和自动化的构建部署等，而人效比是最能直接体现运维效率，衡量人力资源价值的指标。      <br>  <img loading="lazy" alt="image.png" src="/assets/images/1661209671261-4516a7cd-90e9-4a30-9810-42f79ed0f5ca-5fa53b0b5cddad4bfae36ada993ce6c4.png" width="721" height="429" class="img_ev3q"><img loading="lazy" alt="image.png" src="/assets/images/1661209671447-dd9dac8e-11b3-499d-a271-10e5cfd26d74-0f459b76840f2b79633b020455165ac2.png" width="723" height="373" class="img_ev3q"></p><a name="ytjAu"></a><h4 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="34-运营中心">3.4 运营中心<a class="hash-link" href="#34-运营中心" title="标题的直接链接">​</a></h4><p>运营中心从质量、成本、效率三个维度，提供应用的实时健康分、健康实例统计、应用可用率、应用成本占比、资源分配、运维人效、运维操作统计等关键数据看板，致力于保证用户获取准确可靠的应用运行状况、健康趋势、成本资源水位以及人力消耗，从而作出稳定性保障、预算准备、资源扩容等运维决策。<br><img loading="lazy" alt="image.png" src="/assets/images/1661209672316-d9adc066-42c3-4b5f-b4fd-9058205a92d1-0d68b789f8151454d8d2e1f6cdace9a1.png" width="2168" height="853" class="img_ev3q"></p><a name="v0ZYc"></a><h3 class="anchor anchorWithHideOnScrollNavbar_WYt5" id="4-结语">4. 结语<a class="hash-link" href="#4-结语" title="标题的直接链接">​</a></h3><p>随着阿里巴巴云原生大数据运维平台SREWorks的开源，我们得以将其中的数据化运维思想和运维实践分享给大家，抛砖引玉，希望能给大家带来不一样的思想碰撞。同时欢迎大家持续关注我们的开源数据化平台，期待与您进行沟通交流，一起推动云原生数据化运维的发展建设。</p><p>项目地址：<a href="https://github.com/alibaba/sreworks" target="_blank" rel="noopener noreferrer">https://github.com/alibaba/sreworks</a><br>如需免费试用了解阿里云ES请戳 <a href="https://www.aliyun.com/product/bigdata/elasticsearch" target="_blank" rel="noopener noreferrer">阿里云Elasticsearch</a></p>]]></content>
    </entry>
</feed>